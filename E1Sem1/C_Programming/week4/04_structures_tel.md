

#   C లో `struct`


**(Motivation $\rightarrow$ Definition $\rightarrow$ Memory $\rightarrow$ Usage $\rightarrow$ Comparison $\rightarrow$ Pitfalls $\rightarrow$ Closure)**


## 1\. `union` ఎందుకు సరిపోలేదు? (Struct అవసరం ఏంటి?)


`struct` గురించి చెప్పుకునే ముందు, `union` లో ఉన్న సమస్య ఏంటో మరోసారి గుర్తుచేసుకుందాం. ఎందుకంటే ఆ సమస్యను పరిష్కరించడానికే `struct` పుట్టింది.


`union` గురించి మనం ఏం నేర్చుకున్నాం?


> **"యూనియన్ ఒకే మెమరీని వాడుకుంటుంది. ఒకేసారి ఒక్క మెంబర్ మాత్రమే ఉండగలదు."**


ఇప్పుడు ఈ రియల్ లైఫ్ అవసరం చూడండి:


> **"నాకు ఒక స్టూడెంట్ వివరాలు స్టోర్ చేయాలి."**


ఒక స్టూడెంట్ కి ఏముంటాయి?


 * రోల్ నంబర్ (Integer)
 * మార్కులు (Float)
 * గ్రేడ్ (Character)


ఇక్కడ పాయింట్ ఏంటంటే:


1. ఇవన్నీ **కలిసి ఉండాలి**.
2. ఇవన్నీ **ఒకేసారి పనికొస్తాయి** (రోల్ నంబర్ ఉంటూనే మార్కులు కూడా ఉండాలి కదా\!).


### `union` వాడితే వచ్చే సమస్య (తప్పు పద్ధతి)


```c
union Student {
   int roll;
   float marks;
   char grade;
};
```


మనం ఇలా రాసాం అనుకోండి:


```c
s.roll = 10;
s.marks = 85.5;
```


**ఏం జరుగుతుంది?**


 * `marks` వచ్చి `roll` ని ఓవర్ రైట్ (Overwrite) చేస్తుంది.
 * రోల్ నంబర్ డిలీట్ అయిపోతుంది.


### అసలు పాయింట్ (Key Insight)


**డేటా అంతా కలిసి ఉండాలి అనుకున్నప్పుడు Union పనికిరాదు.**
కాబట్టి మనకు ఒక కొత్త పద్ధతి కావాలి:


> **"ప్రతి మెంబర్ కి దాని సొంత మెమరీ (Separate Memory) కావాలి."**


ఆ పద్ధతి పేరే **Structure (స్ట్రక్చర్)**.


-----


## 2\. అసలు `struct` అంటే ఏంటి? (Core Definition)


> **Structure అనేది మనం క్రియేట్ చేసుకునే డేటా టైప్. ఇందులో రకరకాల వేరియబుల్స్ ని ఒక గ్రూప్ గా చేయొచ్చు. ముఖ్యంగా, ఇందులో ప్రతి మెంబర్ కి దాని సొంత మెమరీ (Independent Memory) ఉంటుంది.**


ఈ ఒక్క ముక్క స్ట్రక్చర్స్ సారాంశం.


-----


## 3\. Structure ని డిఫైన్ చేయడం — లైన్-బై-లైన్ వివరణ


### 3.1 Structure Definition (బ్లూప్రింట్ దశ)


```c
struct Student {
   int roll;
   float marks;
   char grade;
};
```


ఇప్పుడు ఒక్కో పదాన్ని విడదీసి చూద్దాం.


**Line 1:** `struct Student {`


 * `struct` $\rightarrow$ **keyword**. కంపైలర్ కి చెప్తుంది: *"నేను ఒక స్ట్రక్చర్ ని డిఫైన్ చేస్తున్నా."*
 * `Student` $\rightarrow$ **స్ట్రక్చర్ పేరు**. `int`, `float` లాగే ఇదొక పేరు.
 * `{` $\rightarrow$ **లిస్ట్ మొదలు**.


 **ముఖ్యమైన విషయం (బాగా గుర్తుపెట్టుకోండి):**
ఇక్కడ:


1. ఇంకా **మెమరీ అలకేట్ అవ్వలేదు.**
2. మనం కేవలం ఒక **టైప్** ని (ఒక రూల్ ని) మాత్రమే రాసాం.
3. ఇది ఇంటి ప్లాన్ (Blueprint) లాంటిది, ఇల్లు ఇంకా కట్టలేదు.


**Line 2:** `int roll;`


 * **అర్థం:** *"ఈ స్ట్రక్చర్ లో `roll` అనే పేరుతో ఒక ఇంటిజర్ ఉంటుంది."*


**Line 3:** `float marks;`


 * **అర్థం:** *"ఈ స్ట్రక్చర్ లో `marks` అనే పేరుతో ఒక ఫ్లోట్ ఉంటుంది."*


**Line 4:** `char grade;`


 * **అర్థం:** *"ఈ స్ట్రక్చర్ లో `grade` అనే పేరుతో ఒక క్యారెక్టర్ ఉంటుంది."*


**Line 5:** `};`


 * డెఫినిషన్ ముగిసింది. **సెమీకోలన్ (;) ఖచ్చితంగా పెట్టాలి.**


-----


## 4\. `struct` vs `union` (అసలు తేడా ఇదే)


ఈ తేడా క్లియర్ గా తెలియాలి.


| లక్షణం | `union` | `struct` |
| :--- | :--- | :--- |
| **మెమరీ** | షేర్ చేసుకుంటాయి (Shared) | ఎవరిది వాళ్ళకే (Separate) |
| **ఎవరుంటారు?** | ఒకేసారి ఒక్కరు (One at a time) | అందరూ ఒకేసారి (All at once) |
| **సైజు** | అందరిలో పెద్ద మెంబర్ సైజు | అందరి సైజుల మొత్తం (Sum) |
| **రియల్ లైఫ్** | ❌ డేటా కలిసి ఉండదు | ✅ పర్ఫెక్ట్ గా సెట్ అవుతుంది |
| **సేఫ్టీ** | రిస్క్ ఎక్కువ | చాలా సేఫ్ |


-----


## 5\. Structure Variable ని డిక్లేర్ చేయడం (మెమరీ అలకేషన్)


ఇప్పుడు మామూలు వేరియబుల్ కి దీనికి తేడా చూద్దాం.


**Normal Variable:**


```c
int x;
```


 * ఒక ఇంటిజర్ కోసం మెమరీ ఇస్తుంది.


**Structure Variable:**


```c
struct Student s;
```


 * **అర్థం:** *"`struct Student` లో ఉన్న మెంబర్స్ **అందరికీ** సరిపోయేంత మెమరీని అలకేట్ చేసి, దానికి `s` అని పేరు పెట్టు."*
 * **ఇక్కడే** అసలైన మెమరీ క్రియేట్ అవుతుంది.


-----


## 6\. Structure మెమరీ ఎలా ఉంటుంది? (Very Important)


ఉదాహరణకు:


```c
struct Student {
   int roll;     // 4 bytes
   float marks;  // 4 bytes
   char grade;   // 1 byte
};
```


`s` కోసం క్రియేట్ అయిన మెమరీ సుమారుగా ఇలా ఉంటుంది:


| roll (4 bytes) | marks (4 bytes) | grade (1 byte) | ...padding... |


**మొత్తం సైజు:**


 * యూనియన్ లాగా మ్యాక్సిమం సైజు **కాదు**.
 * మెంబర్స్ అందరి సైజుల **మొత్తం (Sum)**.


ఇదే యూనియన్ కి దీనికి ఉన్న పెద్ద తేడా.


-----


## 7\. Structure Variable ని ఎలా వాడాలి? (Dot Operator)


### వాల్యూస్ ఇవ్వడం


```c
s.roll = 10;
s.marks = 85.5;
s.grade = 'A';
```


**అర్థం:**


1. రోల్ నంబర్ ని స్టోర్ చెయ్యి.
2. మార్క్స్ ని స్టోర్ చెయ్యి.
3. గ్రేడ్ ని స్టోర్ చెయ్యి.
4. **అన్నీ ఒకేసారి మెమరీలో సేఫ్ గా ఉంటాయి.**


### 8\. Dot (`.`) Operator — లోతుగా అర్థం చేసుకోవడం


డాట్ ఆపరేటర్ అంటే:


> **"స్ట్రక్చర్ వేరియబుల్ లోపల ఉన్న మెంబర్ ని యాక్సెస్ చేయడం."**


**ఉదాహరణలు:**


 * `s.roll`
 * `s.marks`
 * `s.grade`


**చదివే విధానం:** *"`s` అనే స్ట్రక్చర్ లోపల ఉన్న `roll` అనే మెంబర్"*.


-----


## 9\. మొదటి పూర్తి ప్రోగ్రామ్ (Observation)


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
   char grade;
};


int main(void) {
   // స్ట్రక్చర్ వేరియబుల్ ని క్రియేట్ చేసాం
   struct Student s;


   // మెంబర్స్ కి వాల్యూస్ ఇచ్చాం
   s.roll = 10;
   s.marks = 85.5;
   s.grade = 'A';


   // మెంబర్స్ ని ప్రింట్ చేస్తున్నాం
   printf("Roll: %d\n", s.roll);
   printf("Marks: %.2f\n", s.marks);
   printf("Grade: %c\n", s.grade);


   return 0;
}
```


**స్టూడెంట్స్ గమనించాల్సిన విషయం:**


1. టైప్ ని డిఫైన్ చేసాం.
2. వేరియబుల్ ని డిక్లేర్ చేసాం.
3. వాల్యూస్ ఇచ్చాం.
4. ప్రింట్ చేసాం.
5. **ఏ డేటా కూడా డిలీట్ అవ్వలేదు (No data loss).**


-----


## 10\. రియల్ లైఫ్ కి స్ట్రక్చర్స్ ఎందుకు సెట్ అవుతాయి?


కేవలం నంబర్స్ కోసమే కాకుండా, నిజ జీవితంలో ఉండే వస్తువుల (Entities) గురించి డేటా స్టోర్ చేయడానికి స్ట్రక్చర్స్ వాడతాం.


**ఉదాహరణలు:**


 * Student (స్టూడెంట్)
 * Employee (ఉద్యోగి)
 * Date (తేదీ)
 * Book (పుస్తకం)


ప్రతి దానికీ:


1. **చాలా ప్రాపర్టీస్ ఉంటాయి.**
2. **అవన్నీ కలిసి ఉంటాయి.**


అందుకే `struct` మనకు చాలా అవసరం.


-----


## 11\. Structures vs Arrays vs Unions (పోలిక)


చాలా మంది స్టూడెంట్స్ ఈ మూడింటి మధ్య కన్ఫ్యూజ్ అవుతారు. కానీ అవి వేర్వేరు పనుల కోసం వాడతారు.


### 11.1 Structures vs Arrays


**Array అంటే ఏంటి?**


```c
int marks[5];
```


 * **అర్థం:** *"ఒకే రకమైన (Same type) 5 బాక్సులు వరుసగా కావాలి."*
 * **వాడేది:** కలెక్షన్ల కోసం.
 * **యాక్సెస్:** ఇండెక్స్ (`[]`) ద్వారా.


**Structure అంటే ఏంటి?**


```c
struct Student { ... };
```


 * **అర్థం:** *"రకరకాల డేటా (Different types) ఉన్న ఒక మనిషి/వస్తువు వివరాలు కావాలి."*
 * **వాడేది:** ఒక ఎంటిటీ (Entity) కోసం.
 * **యాక్సెస్:** డాట్ (`.`) ద్వారా.


**తేడా:**
మనం `int roll[50]`, `float marks[50]` అని విడివిడిగా ఎరేస్ రాస్తే డేటా చెల్లాచెదురుగా ఉంటుంది. స్ట్రక్చర్ అయితే ఒక స్టూడెంట్ డేటా అంతా ఒకే చోట పెడుతుంది.


| ఫీచర్ | Array | Structure |
| :--- | :--- | :--- |
| **Data type** | అన్నీ ఒక్కటే (Same) | వేర్వేరు (Different) |
| **Purpose** | కలెక్షన్ (Collection) | ఒక ఆబ్జెక్ట్ (Entity) |
| **Access** | Index `[]` | Dot `.` |
| **Meaning** | చాలా వాల్యూస్ | ఒకే ఆబ్జెక్ట్ |


### 11.2 Structures vs Unions (సింపుల్ ఉదాహరణ)


 * **Union** $\rightarrow$ ఒక రూమ్, దానికి రకరకాల బోర్డులు (పగలు ఆఫీసు, రాత్రి బెడ్ రూమ్ - ఒకేసారి ఒక్కటే).
 * **Structure** $\rightarrow$ ఒక ఇల్లు, అందులో చాలా రూమ్స్ (బెడ్ రూమ్, కిచెన్ అన్నీ ఒకేసారి వాడుకోవచ్చు).


-----


## 12\. ఎప్పుడు ఏది వాడాలి? (Decision Rule)


ఈ లాజిక్ గుర్తుపెట్టుకోండి:


1. **అన్ని వాల్యూస్ కలిసి ఉండాలా?**
     * **అవును** $\rightarrow$ **Structure** వాడండి.
     * **కాదు** $\rightarrow$ నెక్స్ట్ ప్రశ్న చూడండి.
2. **ఏదో ఒక్కటే ఉండాలా (Mutually exclusive)?**
     * **అవును** $\rightarrow$ **Union** వాడండి.
3. **అన్నీ ఒకే టైప్, మరియు చాలా ఉన్నాయా?**
     * **అవును** $\rightarrow$ **Array** వాడండి.


-----


## 13\. స్ట్రక్చర్స్ లో చేసే కామన్ తప్పులు (Common Mistakes)


**సూచన:** `❌` గుర్తు ఉన్న లైన్ లో తప్పు ఉంది. ఆ కింద ఉన్న వివరణ చదవండి.


###  Mistake 1: ఇనిషియలైజ్ చేయకుండా వాడటం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s;
   printf("%d %.2f\n", s.roll, s.marks);  // ❌ గార్బేజ్ వాల్యూస్ వస్తాయి
   return 0;
}
```


**వివరణ:** `struct Student s;` అంటే మెమరీ మాత్రమే వస్తుంది, వాల్యూస్ రావు. అందులో చెత్త (Garbage) ఉంటుంది.
**గుర్తుపెట్టుకోండి:** *"Declaration స్పేస్ ఇస్తుంది, వాల్యూస్ ఇవ్వదు."*


###  Mistake 2: స్ట్రక్చర్ మెంబర్స్ కి డీఫాల్ట్ గా 0 వస్తుందనుకోవడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s;   // ❌ roll = 0 అనుకోవడం తప్పు
   if (s.roll == 0) {
       printf("Roll is zero\n");
   }
   return 0;
}
```


**వివరణ:** C లాంగ్వేజ్ ఆటోమేటిక్ గా 0 ని ఇవ్వదు. మీరు వాల్యూ ఇవ్వకుండా చెక్ చేయడం వేస్ట్.
**రూల్:** వాడే ముందు కచ్చితంగా వాల్యూ ఇవ్వాలి.


###  Mistake 3: ఎరే లాగా ఇనిషియలైజ్ చేయడానికి ట్రై చేయడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s = [10, 85.5];  // ❌ స్క్వేర్ బ్రాకెట్స్ వాడకూడదు
   return 0;
}
```


**వివరణ:** `[]` కేవలం ఎరేస్ కి మాత్రమే. స్ట్రక్చర్స్ కి **కర్లీ బ్రేసెస్ `{}`** వాడాలి.


###  Mistake 4: ఇండెక్స్ వాడి యాక్సెస్ చేయడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s;
   s[0] = 10;   // ❌ స్ట్రక్చర్ ఎరే కాదు
   return 0;
}
```


**వివరణ:** స్ట్రక్చర్ అనేది కలెక్షన్ కాదు. `s[0]` అని రాయకూడదు. మెంబర్ **పేరు** (`s.roll`) తోనే పిలవాలి.


###  Mistake 5: ఒకే టైప్ డేటా ఉందని ఎరే అనుకోవడం


```c
#include <stdio.h>


struct Data {
   int a;
   int b;
};


int main(void) {
   struct Data d;
   d[1] = 20;   // ❌ తప్పు
   return 0;
}
```


**వివరణ:** లోపల అన్నీ `int` లే ఉన్నా సరే, స్ట్రక్చర్ ఎరే లాగా ప్రవర్తించదు. `d.a`, `d.b` అనే అనాలి.


### Mistake 6: స్ట్రక్చర్ లో కూడా డేటా ఓవర్ రైట్ అవుతుందని భయపడటం (Union భయం)


```c
#include <stdio.h>


struct Data {
   int x;
   float y;
};


int main(void) {
   struct Data d;
   d.x = 10;
   d.y = 5.5;   // ❌ x పోతుందేమో అని భయం
   printf("%d\n", d.x);
   return 0;
}
```


**వివరణ:** ఈ భయం యూనియన్ వల్ల వస్తుంది. స్ట్రక్చర్ లో `x` కి, `y` కి **వేరు వేరు మెమరీ** ఉంటుంది. `y` ని మారిస్తే `x` కి ఏమీ కాదు.


###  Mistake 7: స్ట్రక్చర్ ని కాపీ చేయలేమని అనుకోవడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s1, s2;
   s1.roll = 10;
   s2 = s1;          // ❌ ఇది పనిచేస్తుందా లేదా అని డౌట్
   printf("%d\n", s2.roll);
   return 0;
}
```


**వివరణ:** `s2 = s1;` అని రాస్తే, `s1` లో ఉన్న డేటా అంతా `s2` లోకి కాపీ అవుతుంది. ఇది వాలిడ్.
**ముఖ్య గమనిక:** స్ట్రక్చర్ అసైన్మెంట్ మొత్తం ఆబ్జెక్ట్ ని కాపీ చేస్తుంది.


-----


## 14\. ఫైనల్ గా గుర్తుపెట్టుకోవాల్సిన మాట (Mental Model)


> **Structure అనేది ఒక కంటైనర్ (Container). అందులో ఉండే ప్రతి మెంబర్ కి దాని సొంత మెమరీ ఉంటుంది. రిలేటెడ్ డేటా అంతా కలిసి, సేఫ్ గా ఉండటానికి ఇది బెస్ట్.**


-----


## 15\. ముగింపు (Structure – Part 1 Closure)


**స్టూడెంట్స్ గుర్తుంచుకోవాల్సినవి:**


1. `struct` అనేది మనమే క్రియేట్ చేసుకునే డేటా టైప్.
2. ప్రతి మెంబర్ కి **సెపరేట్ మెమరీ** ఉంటుంది.
3. సైజు = మెంబర్స్ అందరి సైజుల **మొత్తం**.
4. డాట్ (`.`) ఆపరేటర్ వాడి మెంబర్స్ ని యాక్సెస్ చేస్తాం.
5. స్టూడెంట్, ఎంప్లాయీ వంటి రియల్ లైఫ్ డేటాకి ఇది పర్ఫెక్ట్.
6. యూనియన్ లో ఉన్న సమస్యను ఇది పరిష్కరిస్తుంది.


**ఒక్క ముక్కలో చెప్పాలంటే:**


> **డేటా అంతా కలిసి ఉండాలంటే `struct` వాడండి. ఏదో ఒక్కటే ఉండాలంటే `union` వాడండి.**


