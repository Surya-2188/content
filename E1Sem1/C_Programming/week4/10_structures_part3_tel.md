

# పూర్తి సెక్షన్


## C లో Array of Structures — అర్థం, ఉపయోగం మరియు రాసే పద్ధతి


చాలామంది స్టూడెంట్స్ కి ఒక డౌట్ వస్తుంది:


> **"సార్, స్ట్రక్చర్స్ డేటాని గ్రూప్ చేస్తాయి కదా... మళ్ళీ ఈ 'Array of Structures' గొడవ ఏంటి?"**


దీనికి సమాధానం చాలా సింపుల్. నిదానంగా చూద్దాం.


-----


## 1\. సమస్య ఎక్కడ మొదలైంది? (సాధారణ Arrays ఎందుకు ఫెయిల్ అయ్యాయి?)


### 1.1 విడివిడి ఎరేస్ వాడితే వచ్చే సమస్య (Bad Design)


ఉదాహరణకు మనకు **5గురు స్టూడెంట్స్** డేటా కావాలి:


 * రోల్ నంబర్
 * మార్కులు


బిగినర్స్ సాధారణంగా ఇలా రాస్తారు:


```c
#include <stdio.h>


int main(void) {
   // రెండు వేర్వేరు ఎరేస్
   int roll[5]   = {1, 2, 3, 4, 5};
   float marks[5] = {78.5, 82.0, 91.0, 66.5, 74.0};


   // 2వ స్టూడెంట్ (Index 2) వివరాలు ప్రింట్ చేయడం
   printf("Roll: %d, Marks: %.2f\n", roll[2], marks[2]);
   return 0;
}
```


### ఇది ఎందుకు ప్రాబ్లమ్?


1. **డేటా విడిపోయింది:** `roll` ఎరే ఒక చోట ఉంది, `marks` ఎరే ఇంకో చోట ఉంది.
2. **గ్యారెంటీ లేదు:** `roll[2]` మరియు `marks[2]` ఒకే మనిషివి అని మనం *నమ్ముతున్నాం* అంతే. కోడ్ లో వాటికి లింక్ లేదు.
3. **సార్టింగ్ కష్టం:** మీరు మార్కుల ప్రకారం సార్ట్ చేసారనుకోండి, `marks` ఎరే మారుతుంది కానీ `roll` ఎరే మారదు. అప్పుడు డేటా తారుమారైపోతుంది (మిస్ మ్యాచ్).
4. **ఫంక్షన్స్ కి కష్టం:** ఒక స్టూడెంట్ ని పంపాలంటే, రెండు ఎరేస్ ని, ఒక ఇండెక్స్ ని పంపాలి.


ఇది మంచి పద్ధతి కాదు.


-----


## 2\. స్ట్రక్చర్స్ గ్రూపింగ్ చేస్తాయి, కానీ కౌంట్ పెంచలేవు


స్ట్రక్చర్ వాడితే గ్రూపింగ్ సమస్య తీరుతుంది:


```c
struct Student {
   int roll;
   float marks;
};
```


ఇప్పుడు `roll`, `marks` ఫెవికాల్ వేసినట్టు అతుక్కుని ఉంటాయి.


**కానీ ఇది "ఒక్క" స్టూడెంట్ ని మాత్రమే క్రియేట్ చేస్తుంది.**


మనకు 100 మంది కావాలంటే? ఇలా రాయడం చాలా కష్టం:


```c
struct Student s1, s2, s3, s4, s5, ...;
```


 * రాయడం కష్టం (Repetitive).
 * లూప్ తిప్పలేం (`s[i]` అని రాయలేం కదా).
 * 1000 మంది ఉంటే అసాధ్యం.


అందుకే మనకు ఇంకో మార్గం కావాలి.


-----


## 3\. పరిష్కారం: Array of Structures (Key Idea)


> **"స్ట్రక్చర్ వేరియబుల్స్ ని వరుసగా, ఒక కలెక్షన్ లాగా స్టోర్ చేయడమే 'Array of Structures'."**


ఇది మనకు రెండు పవర్స్ ఇస్తుంది:


1. **Grouping (కలపడం):** స్ట్రక్చర్ డేటాని కలిపి ఉంచుతుంది.
2. **Repetition (కౌంట్):** ఎరే మనకు కావాల్సినంత మందిని ఇస్తుంది (`s[i]`).


-----


## 4\. Array of Structures ని ఎలా డిఫైన్ చేయాలి?


### 4.1 పూర్తి ప్రోగ్రామ్


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   // 3 స్ట్రక్చర్స్ ఉన్న ఎరే
   struct Student s[3];


   // మొదటి స్టూడెంట్ కి వాల్యూస్ ఇవ్వడం
   s[0].roll = 1;
   s[0].marks = 85.5;


   // రెండో స్టూడెంట్
   s[1].roll = 2;
   s[1].marks = 90.0;


   // మూడో స్టూడెంట్
   s[2].roll = 3;
   s[2].marks = 78.0;


   // లూప్ వాడి అందరినీ ప్రింట్ చేయడం
   for (int i = 0; i < 3; i++) {
       printf("Roll: %d, Marks: %.2f\n", s[i].roll, s[i].marks);
   }


   return 0;
}
```


-----


## 5\. లైన్-బై-లైన్ వివరణ


### Structure Definition


```c
struct Student { ... };
```


ఇది జస్ట్ బ్లూప్రింట్ (డిజైన్) మాత్రమే. మెమరీ ఇంకా రాలేదు.


### Array Declaration


```c
struct Student s[3];
```


**అర్థం:** *"నాకు 3 `Student` బాక్సులు వరుసగా కావాలి."*


సో మనకు `s[0]`, `s[1]`, `s[2]` వచ్చాయి.


 * ప్రతి ఎలిమెంట్ ఒక **పూర్తి స్ట్రక్చర్**.
 * ప్రతి బాక్స్ లోపల మళ్ళీ సొంత `roll`, `marks` ఉంటాయి.


### Access Pattern (చాలా ముఖ్యం)


```c
s[i].roll
s[i].marks
```


**చదివే విధానం:** *"`i` వ స్టూడెంట్ యొక్క రోల్ నంబర్"*.


ఇక్కడ రెండు పనులు జరుగుతున్నాయి:


1. ఎరే ఇండెక్స్ (`[]`) వాడి **ఏ స్టూడెంట్** అని సెలెక్ట్ చేసాం.
2. డాట్ (`.`) వాడి ఆ స్టూడెంట్ లోని **ఏ మెంబర్** అని సెలెక్ట్ చేసాం.


-----


## 6\. ఇది రియల్ లైఫ్ లో ఎందుకు పవర్ఫుల్?


### దీని వల్ల ఉపయోగాలు:


1. **డేటా సేఫ్:** మీరు `s[0]` మరియు `s[1]` ని స్వాప్ (Swap) చేస్తే, వాళ్ళ రోల్ నంబర్, మార్క్స్ అన్నీ కలిసే వెళ్తాయి. డేటా మిస్ మ్యాచ్ అవ్వదు.
2. **ఈజీ లూపింగ్:** `for` లూప్ వాడి 1000 మంది రికార్డ్స్ ని సెకన్లలో ప్రింట్ చేయొచ్చు.
3. **డేటాబేస్ స్టైల్:** నిజమైన డేటాబేస్ టేబుల్స్ లో "Rows" ఎలా ఉంటాయో, ఇది సరిగ్గా అలాగే ఉంటుంది.


-----


## 7\. యూజర్ నుండి ఇన్పుట్ తీసుకోవడం (scanf)


రియల్ ప్రోగ్రామ్స్ లో మనం వాల్యూస్ ఫిక్స్ చేయం. యూజర్ ని అడుగుతాం.


### పూర్తి ప్రోగ్రామ్


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s[3];


   // Input Loop
   for (int i = 0; i < 3; i++) {
       printf("Enter roll and marks for student %d: ", i + 1);
       scanf("%d %f", &s[i].roll, &s[i].marks);
   }


   // Output Loop
   printf("\nStudent Records:\n");
   for (int i = 0; i < 3; i++) {
       printf("Roll: %d, Marks: %.2f\n", s[i].roll, s[i].marks);
   }


   return 0;
}
```


### ముఖ్యమైన లైన్


```c
scanf("%d", &s[i].roll);
```


ఇక్కడ `&` ఎందుకు వాడాం? ఎందుకంటే `scanf` కి వాల్యూ స్టోర్ చేయడానికి **అడ్రస్** కావాలి.


 * `s[i]` $\rightarrow$ ఆ స్టూడెంట్ బాక్స్ దగ్గరికి వెళ్తుంది.
 * `.roll` $\rightarrow$ ఆ బాక్స్ లోని `roll` గదికి వెళ్తుంది.
 * `&` $\rightarrow$ ఆ గది అడ్రస్ ని ఇస్తుంది.


-----


## 8\. మెమరీలో ఇవి ఎలా ఉంటాయి? (Visual Idea)


ఒక ఎరే ఆఫ్ స్ట్రక్చర్స్ మెమరీలో **వరుసగా (Sequentially)** ఉంటుంది.


ఊహించుకోండి:


```text
[  s[0]  ] [  s[1]  ] [  s[2]  ]
```


`s[0]` ని జూమ్ చేసి చూస్తే:


```text
| roll (4B) | marks (4B) | ... | roll (4B) | marks (4B) | ...
```


ఎక్కడా గ్యాప్స్ ఉండవు. దీనివల్ల కంప్యూటర్ దీన్ని చాలా ఫాస్ట్ గా చదవగలదు.


-----


## 9\. Array of Structures vs Array of Pointers (చిన్న క్లారిటీ)


ఈ రెండింటిని కన్ఫ్యూజ్ అవ్వకండి:


1. `struct Student s[10];`
     * **Array of Structures:** బాక్సులు అన్నీ ఇక్కడే వరుసగా ఉంటాయి.
2. `struct Student *p[10];`
     * **Array of Pointers:** ఇది కేవలం అడ్రస్ లను దాచుకుంటుంది. అసలు స్ట్రక్చర్స్ వేరే చోట (`malloc` లో) ఉంటాయి.


మనం ఇప్పుడు చెప్పుకుంటున్నది నంబర్ \#1 గురించి.


-----


# సాధారణ తప్పులు (Common Mistakes)


స్ట్రక్చర్ ఎరేస్ వాడేటప్పుడు స్టూడెంట్స్ చేసే తప్పులు ఇవి:


###  Mistake 1: స్ట్రక్చర్ ని 2D ఎరే అనుకోవడం


```c
s[i][j] = 10;    // ❌ తప్పు (WRONG)
```


**వివరణ:** స్ట్రక్చర్స్ కి ఇండెక్స్ లు ఉండవు. పేర్లు (`.roll`, `.marks`) మాత్రమే ఉంటాయి. ఎరే పార్ట్ కి మాత్రమే `[]` వాడాలి.


###  Mistake 2: డాట్ (.) మర్చిపోవడం


```c
s[i]roll = 5;   // ❌ తప్పు
```


**వివరణ:** `s[i]` కి `roll` కి మధ్య సంబంధం చెప్పడానికి డాట్ (`.`) కచ్చితంగా ఉండాలి. (`s[i].roll`).


###  Mistake 3: ఎరే మీద `->` వాడటం


```c
s[i]->roll = 5;   // ❌ తప్పు
```


**వివరణ:** `s[i]` అనేది ఒక బాక్స్ (వేరియబుల్), పాయింటర్ కాదు. బాక్స్ మీద డాట్ (`.`) వాడాలి. పాయింటర్ అయితేనే ఆరో (`->`) వాడాలి.


###  Mistake 4: లూప్ లిమిట్ కోసం `sizeof(s)` వాడటం


```c
for (int i = 0; i < sizeof(s); i++)  // ❌ తప్పు
```


**వివరణ:** `sizeof(s)` బైట్స్ ఇస్తుంది (ఉదాహరణకు 100 బైట్లు), కౌంట్ ఇవ్వదు (3 స్టూడెంట్స్ అని చెప్పదు).
**Correct Way:** `int n = sizeof(s) / sizeof(s[0]);`


###  Mistake 5: ఇండెక్స్ లు మార్చేయడం


```c
s[0].roll = 1;
s[1].marks = 90.0;   // ❌ సంబంధం లేని స్టూడెంట్
```


**వివరణ:** మీరు 0వ స్టూడెంట్ రోల్ నంబర్ రాసి, 1వ స్టూడెంట్ మార్కులు రాస్తే డేటా గందరగోళం అవుతుంది. ఇండెక్స్ ల విషయంలో జాగ్రత్తగా ఉండాలి.


###  Mistake 6: "Array of Structures" ని "Structure of Arrays" తో పోల్చడం


```c
struct Class {
   int roll[10];
   float marks[10];
};
```


**వివరణ:** ఇది "Structure of Arrays". ఇందులో రోల్ నంబర్లన్నీ ఒకచోట, మార్కులన్నీ ఇంకోచోట ఉంటాయి. ఇది "ఒక స్టూడెంట్" ని గ్రూప్ చేయదు. "Array of Structures" (`struct Student s[10]`) డేటా మోడలింగ్ కి బెస్ట్.


###  Mistake 7: సైజు చెప్పకుండా ఎరే ని ఫంక్షన్ కి పంపడం


```c
printStudents(s);   // ❌ ఎరే సైజు ఎంత?
```


**వివరణ:** C లో ఎరేని ఫంక్షన్ కి పంపినప్పుడు, కేవలం స్టార్టింగ్ అడ్రస్ వెళ్తుంది. అందులో 3గురు ఉన్నారా, 100 మంది ఉన్నారా ఫంక్షన్ కి తెలియదు. సైజు విడిగా పంపాలి: `printStudents(s, 3);`.


-----


## 10\. ఫైనల్ గా మెదడులో ముద్రించుకోవాల్సినవి (Mental Model)


1. **Array:** క్వాంటిటీ (ఎంతమంది?) ఇస్తుంది.
2. **Structure:** మీనింగ్ (ఏమేమి ఉన్నాయి?) ఇస్తుంది.
3. **Array of Structures:** రియల్ లైఫ్ కలెక్షన్ (లిస్ట్ ఆఫ్ రికార్డ్స్) ని ఇస్తుంది.


-----


##  ముగింపు వాక్యం


ఒక **Structure** ఒక వస్తువుని (పుస్తకం లేదా మనిషిని) సూచిస్తే, **Array of Structures** ఒక లైబ్రరీని లేదా ఆఫీస్ ని సూచిస్తుంది. C ప్రోగ్రామింగ్ లో డేటాబేస్ లాంటి పనులన్నీ దీని మీదే నడుస్తాయి.




