


#  చాప్టర్: C లో Pointers, Arrays, Strings, NULL, sizeof మరియు malloc


## 1\. ఈ క్లాస్ లో మనం ఏం నేర్చుకోబోతున్నాం?


ఇంతకుముందు రికర్షన్ (Recursion) పాఠంలో, ప్రోగ్రామ్ ఎలా రన్ అవుతుంది, ఫంక్షన్ కాల్స్ స్టాక్ (Stack) లో ఎలా ఉంటాయి అనేది చూసాం. ఇప్పుడు మనం C లాంగ్వేజ్ లో మరొక ముఖ్యమైన కాన్సెప్ట్ దగ్గరికి వెళ్తున్నాం: **మెమరీ (Memory) మరియు అడ్రస్లు (Addresses).**


ఈ క్లాస్ ఒక పెద్ద ప్రశ్నకు సమాధానం ఇస్తుంది:


> **"అసలు మెమరీతో డైరెక్ట్ గా పనిచేసే పవర్ C మనకు ఎలా ఇస్తుంది?"**


ఈ క్లాస్ లో మనం వరుసగా ఇవి చూస్తాం:


 * మనకు వేరియబుల్స్ ఉండగా, ఈ పాయింటర్స్ (Pointers) ఎందుకు?
 * పాయింటర్ లో ఏం ఉంటుంది? (అడ్రస్).
     * అడ్రస్ కావాలంటే (`&` వాడాలి)
     * అక్కడ ఉన్న వాల్యూ కావాలంటే (`*` వాడాలి)
 * `*` (Star) కి ఉన్న రెండు అర్థాలు:
     * డెఫినిషన్ లో (ఇది పాయింటర్ అని చెప్పడానికి)
     * వాడేటప్పుడు (అక్కడ ఉన్న వాల్యూ తేవడానికి)
 * పాయింటర్ కి డేటా టైప్ (`int*`, `char*`) ఎందుకు అవసరం?
 * పాయింటర్ అర్థమెటిక్ (`p + 1`) అంటే 1 కూడటం కాదు, మరి ఏంటి?
 * పాయింటర్ vs ఎరే (Array): ఎరే పేరు పాయింటర్ లాగా ఎందుకు బిహేవ్ చేస్తుంది?
 * స్ట్రింగ్స్ (Strings): చివర `\0` ఉండే char array అంటే ఏంటి?
 * NULL పాయింటర్: "ఏమీ లేని" పాయింటర్ వల్ల క్రాష్ లు ఎలా ఆగుతాయి?
 * `sizeof`: ఎరే సైజ్ కి, పాయింటర్ సైజ్ కి తేడా ఏంటి?
 * `malloc`: ప్రోగ్రామ్ రన్ అవుతుండగా ఎరే ని ఎలా క్రియేట్ చేయాలి?
 * చివరిగా ఒక పూర్తి ప్రోగ్రామ్ + లైన్-బై-లైన్ వివరణ.


మనం సింపుల్ భాషలో చెప్పుకుందాం. "Dereferencing" లాంటి పెద్ద పెద్ద పదాలు కాకుండా, **"అక్కడ ఉన్న వాల్యూ (Value at)"** అని పిలుద్దాం.


-----


## 2\. మనకు వేరియబుల్స్ ఉండగా పాయింటర్స్ ఎందుకు?


మనకు ఇది తెలుసు:


```c
int x = 10;
```


మనం ఏమనుకుంటాం? **"x లో 10 ఉంది"** అని.


కానీ కంప్యూటర్ లోపల నిజం ఏంటంటే:


1. ఆ వాల్యూ **మెమరీ (Memory)** లో స్టోర్ అయ్యింది.
2. ఆ లొకేషన్ కి ఒక **అడ్రస్ (Address)** ఉంటుంది.
3. మనం పెట్టిన పేరు (`x`) ఆ అడ్రస్ కి ఒక లేబుల్ మాత్రమే.


కాబట్టి ప్రతి వేరియబుల్ కి రెండు ఉంటాయి:


 * **Value (విలువ)**
 * **Address (చిరునామా)**


కొన్నిసార్లు, వాల్యూ ఉంటే సరిపోదు — మనం డైరెక్ట్ గా మెమరీని కంట్రోల్ చేయాలంటే అడ్రస్ కావాలి.


-----


## 3\. వేరియబుల్ కి రెండు భాగాలు: వాల్యూ మరియు లొకేషన్


దీన్ని ఇలా ఊహించుకోండి:


```text
+-----------+
|    10     |   ← value (విలువ)
+-----------+
  2000         ← address (అడ్రస్)
```


సో:


 * `x` అని అడిగితే **Value** వస్తుంది.
 * `&x` అని అడిగితే **Address** వస్తుంది.


-----


## 4\. అసలు Pointer అంటే ఏంటి?


పాయింటర్ అనేది ఒక వేరియబుల్, కానీ ఇది వేరే వేరియబుల్ యొక్క **అడ్రస్** ని స్టోర్ చేసుకుంటుంది.


 * **Normal variable** $\rightarrow$ వాల్యూ ని దాచుకుంటుంది.
 * **Pointer variable** $\rightarrow$ అడ్రస్ ని దాచుకుంటుంది.


-----


## 5\. `&` సింబల్ అంటే "Address Of"


`&` ని ఆంపర్సాండ్ (Ampersand) అంటారు. దీనికి ఒక్కటే అర్థం: **Address of (యొక్క అడ్రస్)**.


**ఉదాహరణ:**


```c
int x = 10;
printf("%p\n", (void*)&x);
```


ఇది `x` ఎక్కడ స్టోర్ అయ్యిందో ఆ మెమరీ అడ్రస్ ని ప్రింట్ చేస్తుంది.


-----


## 6\. పాయింటర్ ని డిక్లేర్ చేయడం (`*` కి మొదటి అర్థం)


పాయింటర్ ని ఇలా క్రియేట్ చేస్తాం:
`data_type *pointer_name;`


**ఉదాహరణలు:**


```c
int *p;
char *c;
float *f;
```


ఇక్కడ `*` అంటే అర్థం: **"ఈ వేరియబుల్ ఒక పాయింటర్ సుమీ"** అని చెప్పడం.
ఇది `*` కి ఉన్న **మొదటి అర్థం**.


-----


## 7\. పాయింటర్ వాడి వాల్యూని తేవడం (`*` కి రెండో అర్థం)


ఒక పాయింటర్ లో అడ్రస్ ఉన్నప్పుడు, ఆ అడ్రస్ లో ఏ వాల్యూ ఉందో మనం `*` వాడి తెలుసుకోవచ్చు.


**ఉదాహరణ:**


```c
int x = 10;
int *p = &x;


printf("%d\n", *p);
```


ఇక్కడ:


 * `p` లో `x` యొక్క అడ్రస్ ఉంది.
 * `*p` అంటే ఆ అడ్రస్ లో ఉన్న **వాల్యూ (Value at)**.


సో వాడేటప్పుడు, `*p` = **అక్కడ ఉన్న వాల్యూ**.
ఇది `*` కి ఉన్న **రెండో అర్థం**.


-----


## 8\. `*` కి ఉన్న రెండు అర్థాలు (ఖచ్చితంగా గుర్తుపెట్టుకోవాలి)


1. **Declaration లో:**
   `int *p;`
   `*` అంటే: **ఇది ఒక పాయింటర్**.


2. **Usage (వాడేటప్పుడు):**
   `*p`
   `*` అంటే: `p` లో ఉన్న అడ్రస్ దగ్గరికి వెళ్లి **అక్కడ ఉన్న వాల్యూ** తీసుకురా.


-----


## 9\. `&` మరియు `*` కాంబినేషన్స్


ఇది చూడండి:


```c
int x = 10;
int *p = &x;
```


ఇప్పుడు టేబుల్ చూద్దాం:


| Expression | Meaning (అర్థం) |
| :--- | :--- |
| `x` | x యొక్క వాల్యూ |
| `&x` | x యొక్క అడ్రస్ |
| `p` | p లో దాగున్న అడ్రస్ |
| `*p` | p చూపిస్తున్న అడ్రస్ లో ఉన్న వాల్యూ |
| `&p` | పాయింటర్ p యొక్క సొంత అడ్రస్ |
| `*&x` | x అడ్రస్ లో ఉన్న వాల్యూ $\rightarrow$ అంటే మళ్ళీ **x** వస్తుంది |
| `&*p` | p లో ఉన్న వాల్యూ యొక్క అడ్రస్ $\rightarrow$ అంటే **x అడ్రస్** |


**సింపుల్ లాజిక్:** `*` మరియు `&` పక్కపక్కన వస్తే, అవి ఒకదానికొకటి క్యాన్సిల్ (Cancel) అయిపోతాయి. `*&something` అంటే మళ్ళీ `something` అనే అర్థం.


-----


## 10\. పాయింటర్ కి డేటా టైప్ ఎందుకు?


చాలామందికి వచ్చే డౌట్: **"అడ్రస్ లు అన్నీ నంబర్లే కదా? మరి `int*`, `char*` అని తేడా ఎందుకు?"**


ఎందుకంటే ఆ టైప్ అడ్రస్ కోసం కాదు. అది కంపైలర్ కి రెండు విషయాలు చెప్తుంది:


1. అక్కడి నుంచి ఎన్ని బైట్లు (Bytes) చదవాలి?
2. ఆ బైట్లని ఎలా అర్థం చేసుకోవాలి? (ఇంటిజర్ లాగానా? ఫ్లోట్ లాగానా?)


మనం `*p` అన్నప్పుడు, కరెక్ట్ గా చదవాలంటే కంపైలర్ కి టైప్ తెలియాలి.


-----


## 11\. Pointer Arithmetic (`p + 1` అంటే ఏంటి?)


పాయింటర్ అర్థమెటిక్ అంటే అడ్రస్ కి "1 కూడటం" కాదు.
దాని అర్థం: **ఆ డేటా టైప్ ప్రకారం, నెక్స్ట్ లొకేషన్ కి వెళ్ళు.**


 * `char*` అయితే $\rightarrow$ **1 byte** ముందుకు వెళ్తుంది.
 * `int*` అయితే $\rightarrow$ **sizeof(int)** బైట్లు (సాధారణంగా 4) ముందుకు వెళ్తుంది.


సో `p + 1` అనేది టైప్ ని బట్టి మారుతుంది.


-----


## 12\. Pointer vs Array (అతి ముఖ్యమైన లింక్)


స్టూడెంట్స్ తరచుగా వినే మాట: *"Array పేరు ఒక పాయింటర్."*
**కరెక్ట్ గా చెప్పాలంటే:**


> **చాలా సందర్భాల్లో, ఎరే పేరు దాని 'మొదటి ఎలిమెంట్ అడ్రస్' లాగా పనిచేస్తుంది.**


**ఉదాహరణ:**


```c
int arr[4] = {10, 20, 30, 40};
```


అప్పుడు: `arr == &arr[0]` (ఎరే పేరు = మొదటి బాక్స్ అడ్రస్).


-----


## 13\. Indexing అంటే Pointer Arithmetic ఏ


ఇది బండ గుర్తు:
$$arr[i] \equiv *(arr + i)$$


సో ఇండెక్సింగ్ (`arr[i]`) అంటే:


1. `i` స్టెప్పులు ముందుకు వెళ్ళు.
2. అక్కడ ఉన్న **వాల్యూ** తీసుకో.


-----


## 14\. Array పేరు Pointer Variable ఎందుకు కాదు?


 * **Pointer Variable ని మార్చొచ్చు:**
   `p = &x;`
   `p = &y;` (ఇది ఓకే)
 * **Array పేరుని మార్చలేం:**
   `arr = &x;`   // **తప్పు (Illegal)**


కాబట్టి:


 * ఎరే పేరు పాయింటర్ లాగా **బిహేవ్** చేస్తుంది.
 * కానీ అది పాయింటర్ **వేరియబుల్** కాదు (అదొక కాన్స్టెంట్ అడ్రస్).


-----


## 15\. Strings: పాయింటర్స్ ని అర్థం చేసుకోవడానికి బెస్ట్ ప్లేస్


C లో స్ట్రింగ్ అంటే: **చివర `\0` (Null) ఉండే char array.**


**ఉదాహరణ:**


```c
char s[] = "HELLO";
```


నిజానికి మెమరీలో ఇలా ఉంటుంది:
`'H' 'E' 'L' 'L' 'O' '\0'`


ఆ `\0` వల్లే స్ట్రింగ్ ఎక్కడ అయిపోయిందో తెలుస్తుంది.


-----


## 16\. `char[]` vs `char*` (ముఖ్యమైన తేడా)


 * **మార్చగలిగే స్ట్రింగ్ (Modifiable):**
   ```c
   char s[] = "HELLO";
   s[0] = 'Y';   // ఇది ఓకే ("YELLO" అవుతుంది)
   ```
 * **రీడ్-ఓన్లీ స్ట్రింగ్ (String literal pointer):**
   ```c
   char *p = "HELLO";
   p[0] = 'Y';   // తప్పు! క్రాష్ అవుతుంది.
   ```


-----


## 17\. NULL Pointer


ఒక పాయింటర్ దేన్నీ చూపించకూడదు అనుకున్నప్పుడు, దానికి `NULL` ఇవ్వొచ్చు.


```c
char *p = NULL;
```


ఎప్పుడూ ఇలా చెక్ చేసుకోవాలి:


```c
if (p != NULL) {
   printf("%s\n", p);
}
```


-----


## 18\. `sizeof` Operator (Array vs Pointer)


ఒకవేళ:


```c
int arr[5];
int *p = arr;
```


అయితే:


 * `sizeof(arr)` $\rightarrow$ మొత్తం ఎరే సైజు $\rightarrow$ $5 \times 4 = 20$ bytes.
 * `sizeof(p)` $\rightarrow$ పాయింటర్ సైజు (అడ్రస్ సైజు) $\rightarrow$ 8 bytes (64-bit సిస్టమ్ లో).


ఇది మళ్ళీ రుజువు చేస్తుంది: **ఎరే మరియు పాయింటర్ ఒకటి కాదు.**


-----


## 19\. ఎరే కోసం `malloc` ఎందుకు వాడాలి?


 * **Static array:** `int arr[5];` (సైజు ముందే ఫిక్స్ అయిపోతుంది).
 * కానీ యూజర్ రన్ టైమ్ లో సైజు చెప్తే? మనం `int arr[n];` అని రాయడం అన్ని కంపైలర్ల లో సేఫ్ కాదు.
 * మనకు **Runtime Memory Allocation** కావాలి.


అందుకే `malloc` వాడతాం.


-----


## 20\. ఫైనల్ ప్రోగ్రామ్: `malloc` వాడి ఎరే క్రియేట్ చేయడం


```c
#include <stdio.h>
#include <stdlib.h>


int main(void) {
   int n, i;
   int *arr;


   printf("Enter number of elements: ");
   scanf("%d", &n);


   // Heap మెమరీ నుండి స్పేస్ అడుగుతున్నాం
   arr = (int *)malloc(n * sizeof(int));


   // మెమరీ దొరికిందో లేదో ఎప్పుడూ చెక్ చేయాలి
   if (arr == NULL) {
       printf("Memory allocation failed\n");
       return 1;
   }


   // ఎరే ని నింపడం (మామూలు ఇండెక్సింగ్ వాడి)
   for (i = 0; i < n; i++) {
       arr[i] = (i + 1) * 10;
   }


   printf("Array elements using pointer arithmetic:\n");


   // పాయింటర్ అర్థమెటిక్ వాడి ప్రింట్ చేయడం
   for (i = 0; i < n; i++) {
       printf("%d ", *(arr + i));
   }


   printf("\n");


   // మెమరీని వెనక్కి ఇచ్చేయడం (Free)
   free(arr);
   return 0;
}
```


-----


## 21\. లైన్-బై-లైన్ వివరణ


ప్రతి లైన్ ఎందుకు రాసామో చూద్దాం.


**21.1 Header Files**


 * `#include <stdio.h>`: `printf`, `scanf` కోసం.
 * `#include <stdlib.h>`: `malloc`, `free` కోసం. ఇది లేకపోతే `malloc` సరిగ్గా పనిచేయదు.


**21.2 Start of Program**


 * `int main(void) {`: ప్రోగ్రామ్ ఇక్కడి నుంచి మొదలవుతుంది.


**21.3 Variable Declarations**


 * `int n, i;`: కౌంట్ కోసం `n`, లూప్ కోసం `i`.
 * `int *arr;`: ఇది `int` కి పాయింటర్.
     * **ముఖ్య గమనిక:** `malloc` మెమరీ ఇచ్చాక, దాని స్టార్టింగ్ అడ్రస్ ని ఇందులో స్టోర్ చేస్తాం. అప్పుడు `arr` ఒక ఎరే పేరులా పనిచేస్తుంది.


**21.4 Taking Input**


 * `scanf("%d", &n);`: ఎన్ని ఎలిమెంట్స్ కావాలో యూజర్ ని అడుగుతాం.


**21.5 Allocating Memory**


 * `arr = (int *)malloc(n * sizeof(int));`
     * `sizeof(int)` $\rightarrow$ ఒక ఇంటిజర్ కి ఎన్ని బైట్లు కావాలి?
     * `n * sizeof(int)` $\rightarrow$ మొత్తం `n` ఇంటిజర్స్ కి ఎన్ని కావాలి?
     * `malloc(...)` $\rightarrow$ అంత మెమరీని **Heap** లో బుక్ చేస్తుంది.
     * ఆ మెమరీ యొక్క **స్టార్టింగ్ అడ్రస్** ని రిటర్న్ చేస్తుంది.
     * ఆ అడ్రస్ ని `arr` లో దాచుకుంటాం.


**21.6 NULL Check ఎందుకు?**


 * `if (arr == NULL)`: ఒకవేళ మెమరీ ఖాళీ లేకపోతే, `malloc` మనకు `NULL` ఇస్తుంది. అది చెక్ చేయకుండా వాడితే ప్రోగ్రామ్ క్రాష్ అవుతుంది.


**21.7 Filling the Array**


 * `arr[i] = (i + 1) * 10;`
     * `arr` అనేది స్టార్టింగ్ అడ్రస్ కాబట్టి, దాన్ని ఎరే లాగా వాడొచ్చు.
     * లోపల జరిగేది ఇదే: `arr[i] ≡ *(arr + i)`.


**21.8 Printing using Pointer Arithmetic**


 * `printf("%d ", *(arr + i));`
     * `*(arr + i)` అంటే: `arr` దగ్గర మొదలుపెట్టి, `i` స్టెప్పులు ముందుకెళ్లి, అక్కడ ఉన్న **వాల్యూ** తీసుకో.
     * దీన్ని బట్టి అర్థమయ్యేది ఏంటంటే: ఎరే అంటే సీక్వెన్స్ గా ఉన్న మెమరీ బాక్సులే.


**21.11 Freeing Memory**


 * `free(arr);`: వాడేసుకున్నాక మెమరీని సిస్టమ్ కి వెనక్కి ఇచ్చేయాలి.
     * **రూల్:** `malloc` రాసామంటే, చివర్లో `free` కచ్చితంగా రాయాలి. లేకపోతే **Memory Leak** అవుతుంది.


-----


## 22\. ముగింపు (Final Conclusion)


ఈ క్లాస్ లో మనం ఏం నేర్చుకున్నాం?


1. వేరియబుల్స్ అంటే మెమరీ లొకేషన్స్.
2. `&` అంటే **అడ్రస్**.
3. `*` కి రెండు అర్థాలు:
     * డెఫినిషన్ లో $\rightarrow$ **ఇది పాయింటర్**.
     * వాడేటప్పుడు $\rightarrow$ **అక్కడ ఉన్న వాల్యూ**.
4. పాయింటర్ అర్థమెటిక్ అనేది టైప్ ని బట్టి స్టెప్స్ వేస్తుంది.
5. ఎరే పేరు అనేది మొదటి ఎలిమెంట్ అడ్రస్ లా పనిచేస్తుంది.
6. `arr[i]` అన్నా `*(arr + i)` అన్నా ఒక్కటే.
7. స్ట్రింగ్స్ అంటే చివర `\0` ఉండే char arrays.
8. `NULL` అంటే పాయింటర్ ఖాళీగా ఉందని అర్థం.
9. `malloc` వాడితే ప్రోగ్రామ్ రన్ అవుతుండగా ఎరే ని క్రియేట్ చేయొచ్చు.


రికర్షన్ అర్థం కావాలంటే స్టాక్ ఎలా అర్థం కావాలో, పాయింటర్స్ అర్థం కావాలంటే మెమరీ మరియు అడ్రస్ లు ఎలా పనిచేస్తాయో తెలియాలి. **పాయింటర్స్ అంటే మ్యాజిక్ కాదు. అవి మెమరీని మనకు కళ్ళకు కట్టినట్టు చూపిస్తాయి అంతే.**


-----


## Pointers, Arrays, Strings, sizeof, మరియు malloc లో చేసే కామన్ తప్పులు


**స్టూడెంట్స్ కి సూచన:**
కింద ఉన్న ప్రతి ప్రోగ్రామ్ లో, `❌` గుర్తు ఉన్న లైన్ లో తప్పు ఉంది. కోడ్ లోపల కాకుండా, దాని కింద ఉన్న వివరణ చదవండి.


### Mistake 1 – అడ్రస్ ఇవ్వకుండా పాయింటర్ వాడటం


```c
#include <stdio.h>


int main(void) {
   int *p;
   *p = 10;   // ❌
   return 0;
}
```


**వివరణ:** `p` డిక్లేర్ చేసాం కానీ దానికి ఏ అడ్రస్ ఇవ్వలేదు (అందులో చెత్త/Garbage ఉంటుంది). ఆ తెలియని అడ్రస్ లో 10 పెట్టడానికి ట్రై చేస్తే ప్రోగ్రామ్ క్రాష్ అవుతుంది.


### Mistake 2 – పాయింటర్ కి `&` లేకుండా వాల్యూ ఇవ్వడం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int *p = x;   // ❌
   return 0;
}
```


**వివరణ:** ఇక్కడ `x` యొక్క **వాల్యూ** (10) ని ఇస్తున్నాం, దాని **అడ్రస్** ని కాదు. పాయింటర్ కి ఎప్పుడూ అడ్రస్ కావాలి, అందుకే `&x` వాడాలి.


### Mistake 3 – పాయింటర్ ని, వాల్యూ ని కన్ఫ్యూజ్ అవ్వడం


```c
#include <stdio.h>


int main(void) {
   int x = 20;
   int *p = &x;
   printf("%d\n", p);   // ❌
   return 0;
}
```


**వివరణ:** `p` ని ప్రింట్ చేస్తే అడ్రస్ వస్తుంది, వాల్యూ కాదు. వాల్యూ కావాలంటే `*p` వాడాలి. అడ్రస్ ప్రింట్ చేయడానికి `%p` వాడాలి.


### Mistake 4 – పాయింటర్ కాని దాని మీద `*` వాడటం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   printf("%d\n", *x);  // ❌
   return 0;
}
```


**వివరణ:** `x` అనేది మామూలు నంబర్, పాయింటర్ కాదు. `*` (value at) అనేది కేవలం పాయింటర్స్ మీద మాత్రమే పనిచేస్తుంది.


### Mistake 5 – `*` యొక్క రెండు అర్థాలను కలపడం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int *p;
   *p = &x;   // ❌
   return 0;
}
```


**వివరణ:** `*p` అంటే "p లో ఉన్న అడ్రస్ దగ్గర ఉన్న వాల్యూ". `&x` అంటే అడ్రస్. ఒక వాల్యూ ప్లేస్ లో అడ్రస్ ని పెట్టలేం. కరెక్ట్ పద్ధతి: `p = &x;`.


### Mistake 6 – తప్పు టైప్ పాయింటర్ వాడటం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   float *p = &x;   // ❌
   return 0;
}
```


**వివరణ:** `int` ని `float` పాయింటర్ తో చదివితే డేటా తప్పుగా వస్తుంది. మెమరీలో బిట్స్ వేరుగా ఉంటాయి.


### Mistake 7 – ఎరే పేరుని మార్చడానికి ట్రై చేయడం


```c
#include <stdio.h>


int main(void) {
   int arr[3] = {1, 2, 3};
   int x = 10;
   arr = &x;   // ❌
   return 0;
}
```


**వివరణ:** `arr` అనేది పాయింటర్ వేరియబుల్ కాదు; అదొక ఫిక్స్డ్ మెమరీ బ్లాక్ పేరు. దాన్ని వేరే చోటికి పాయింట్ చేయలేం.


### Mistake 8 – ఎరే లిమిట్ దాటి యాక్సెస్ చేయడం


```c
#include <stdio.h>


int main(void) {
   int arr[3] = {10, 20, 30};
   printf("%d\n", *(arr + 3));   // ❌
   return 0;
}
```


**వివరణ:** ఉన్న ఇండెక్స్ లు 0, 1, 2 మాత్రమే. `arr + 3` అంటే ఎరే బయట ఉన్న మెమరీని అడుగుతున్నాం.


### Mistake 9 – ఎరే కాని దాని మీద పాయింటర్ అర్థమెటిక్


```c
#include <stdio.h>


int main(void) {
   int x = 5;
   int *p = &x;
   printf("%d\n", *(p + 1));   // ❌
   return 0;
}
```


**వివరణ:** `x` అనేది ఒక్క వేరియబుల్ మాత్రమే. `p + 1` అంటే దాని పక్కన ఉన్న (తెలియని) మెమరీని యాక్సెస్ చేయడం. ఇది డేంజర్.


### Mistake 10 – స్ట్రింగ్ చివర `\0` మర్చిపోవడం


```c
#include <stdio.h>


int main(void) {
   char s[3] = {'A', 'B', 'C'};
   printf("%s\n", s);   // ❌
   return 0;
}
```


**వివరణ:** C లో స్ట్రింగ్స్ చివర `\0` ఉండాలి. అది లేకపోతే `printf` మెమరీలో ఎక్కడో సున్నా దొరికేదాకా ప్రింట్ చేస్తూనే ఉంటుంది (చెత్త ప్రింట్ అవుతుంది).


### Mistake 11 – స్ట్రింగ్ లిటరల్ ని మార్చడం


```c
#include <stdio.h>


int main(void) {
   char *p = "HELLO";
   p[0] = 'Y';   // ❌
   return 0;
}
```


**వివరణ:** `"HELLO"` అనేది రీడ్-ఓన్లీ మెమరీలో ఉంటుంది. దాన్ని మార్చడానికి ట్రై చేస్తే ప్రోగ్రామ్ క్రాష్ అవుతుంది.


### Mistake 12 – `sizeof(pointer)` ఎరే సైజు ఇస్తుందనుకోవడం


```c
#include <stdio.h>


int main(void) {
   int arr[5];
   int *p = arr;
   printf("%zu\n", sizeof(p));   // ❌
   return 0;
}
```


**వివరణ:** `sizeof(p)` పాయింటర్ సైజును ఇస్తుంది (8 బైట్లు), ఎరే సైజును కాదు.


### Mistake 13 – ఫంక్షన్ లోపల `sizeof` వాడటం


```c
#include <stdio.h>


void f(int arr[]) {
   printf("%zu\n", sizeof(arr));   // ❌
}


int main(void) {
   int a[5];
   f(a);
   return 0;
}
```


**వివరణ:** ఫంక్షన్ కి పాస్ చేసినప్పుడు ఎరే, పాయింటర్ గా మారుతుంది. అందుకే అక్కడ `sizeof` వాడితే పాయింటర్ సైజు వస్తుంది కానీ ఎరే సైజు రాదు.


### Mistake 14 – `free` చేసిన తర్వాత పాయింటర్ వాడటం


```c
#include <stdio.h>
#include <stdlib.h>


int main(void) {
   int *p = malloc(sizeof(int));
   free(p);
   *p = 10;   // ❌
   return 0;
}
```


**వివరణ:** `free(p)` తర్వాత ఆ మెమరీ మనది కాదు. దాన్ని వాడటం (Use-After-Free) చాలా ప్రమాదకరం.


### Mistake 15 – మెమరీ `free` చేయడం మర్చిపోవడం


```c
#include <stdlib.h>


int main(void) {
   int *p = malloc(100 * sizeof(int));
   return 0;   // ❌
}
```


**వివరణ:** మెమరీ తీసుకున్నాం కానీ వెనక్కి ఇవ్వలేదు. దీన్నే **Memory Leak** అంటారు.


### Mistake 16 – `malloc` ఫెయిల్ అయ్యిందో లేదో చూడకపోవడం


```c
#include <stdlib.h>


int main(void) {
   int *p = malloc(1000000000 * sizeof(int));
   p[0] = 5;   // ❌
   return 0;
}
```


**వివరణ:** మెమరీ ఫుల్ అయితే `malloc`, `NULL` ఇస్తుంది. అది చెక్ చేయకుండా వాడితే క్రాష్ అవుతుంది.


### Mistake 17 – పాయింటర్ ని `%d` తో ప్రింట్ చేయడం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int *p = &x;
   printf("%d\n", p);   // ❌
   return 0;
}
```


**వివరణ:** పాయింటర్స్ అడ్రస్ లు. వాటిని `%p` తో ప్రింట్ చేయాలి, `%d` తో కాదు.


### Mistake 18 – లోకల్ వేరియబుల్ అడ్రస్ ని రిటర్న్ చేయడం


```c
#include <stdio.h>


int* f(void) {
   int x = 10;
   return &x;   // ❌
}


int main(void) {
   int *p = f();
   return 0;
}
```


**వివరణ:** `x` అనేది ఫంక్షన్ లోపల మాత్రమే బతికి ఉంటుంది. ఫంక్షన్ అయిపోయాక అది చనిపోతుంది. దాని అడ్రస్ ని బయట వాడకూడదు.


### Mistake 19 – డబుల్ పాయింటర్ ని తప్పుగా వాడటం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int **p = &x;   // ❌
   return 0;
}
```


**వివరణ:** `&x` అనేది `int*`. `p` ఏమో `int**`. సింగిల్ పాయింటర్ ని డబుల్ పాయింటర్ లో పెట్టలేం.


### Mistake 20 – ఒక `*` ఉన్నప్పుడు `**` వాడటం


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int *p = &x;
   printf("%d\n", **p);   // ❌
   return 0;
}
```


**వివరణ:** `p` సింగిల్ పాయింటర్. దాని మీద రెండు సార్లు `*` వాడితే ఎర్రర్ వస్తుంది.


### Mistake 21 – పాయింటర్ ని `NULL` తో ఇనిషియలైజ్ చేయకపోవడం


```c
#include <stdio.h>


int main(void) {
   int *p;
   if (p != NULL) {   // ❌
       printf("Valid\n");
   }
   return 0;
}
```


**వివరణ:** `p` లో చెత్త వాల్యూ ఉంటుంది. అది `NULL` కాదు కాబట్టి `if` లోపలికి వెళ్తుంది, కానీ అది వాలిడ్ కాదు. పాయింటర్ ని ఎప్పుడూ `int *p = NULL;` అని మొదలుపెట్టాలి.


### Mistake 22 – `NULL` పాయింటర్ ని వాడటం


```c
#include <stdio.h>


int main(void) {
   char *p = NULL;
   printf("%s\n", p);   // ❌
   return 0;
}
```


**వివరణ:** `p` దేన్నీ చూపించట్లేదు. దాన్ని ప్రింట్ చేయడానికి ట్రై చేస్తే క్రాష్ (Segmentation Fault) అవుతుంది.


### Mistake 23 – `malloc` సైజు తప్పుగా ఇవ్వడం


```c
#include <stdlib.h>


int main(void) {
   int *p = malloc(10);   // ❌
   return 0;
}
```


**వివరణ:** 10 ఇంటిజర్లు కావాలంటే `10 * sizeof(int)` అని రాయాలి. ఊరికే `10` అని రాస్తే 10 బైట్లు మాత్రమే వస్తాయి (అది 2 ఇంటిజర్లకి మాత్రమే సరిపోతుంది).


### Mistake 24 – లూప్ లో Off-By-One Error


```c
#include <stdio.h>


int main(void) {
   int arr[3] = {1,2,3};
   for (int i = 0; i <= 3; i++) {   // ❌
       printf("%d ", arr[i]);
   }
   return 0;
}
```


**వివరణ:** ఇండెక్స్ లు 0, 1, 2 మాత్రమే. `i <= 3` అంటే 3 వ ఇండెక్స్ ని టచ్ చేస్తాం, అది బయట ఉంది.


### Mistake 25 – పాయింటర్ కదిలితే ఎరే మారుతుందనుకోవడం


```c
#include <stdio.h>


int main(void) {
   int arr[3] = {10,20,30};
   int *p = arr;
   p++;   // ❌
   printf("%d\n", arr[0]);
   return 0;
}
```


**వివరణ:** `p++` చేస్తే `p` మారుతుంది, కానీ అసలు ఎరే `arr` అలాగే ఉంటుంది. `arr[0]` స్టిల్ 10 గానే ఉంటుంది.


-----


### చివరి మాట (అతి ముఖ్యమైనది)


రికర్శన్ లో Base Case ఎలాగో, పాయింటర్స్ లో అడ్రస్ లాజిక్ అలాగ.


మీరు ఎప్పుడూ ఈ మూడు ప్రశ్నలు వేసుకుంటే పాయింటర్స్ చాలా ఈజీ:


1. **వాల్యూ (Value) ఎక్కడ ఉంది?**
2. **అడ్రస్ (Address) ఎక్కడ ఉంది?**
3. **నేను వాడుతున్న మెమరీ అసలు నాకు ఉందా (Valid)?**


ఇవి తెలిస్తే పాయింటర్స్ మీ చేతిలో ఉంటాయి\!

