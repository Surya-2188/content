

# చాప్టర్: `return` స్టేట్‌మెంట్‌ని అర్థం చేసుకోవడం (అసలు కథ)


ఇప్పటి వరకు మనం ఫంక్షన్స్ అంటే ఏంటి, వాటిని ఎలా రాయాలి అనేది చూసాం. కానీ, బిగినర్స్ (Beginners) అందరికీ వచ్చే పెద్ద డౌట్ ఒకటి ఉంది:


> *"సార్, అసలు ఈ `return` ఎందుకు రాయాలి?"*
> *"అది ఏం రిటర్న్ చేస్తోంది? ఎవరికి ఇస్తోంది?"*


ఈ కన్ఫ్యూజన్ రావడానికి మెయిన్ రీజన్ ఏంటంటే.. మనం చిన్నప్పటి నుంచి మ్యాథ్స్ (Mathematics) లో చూసిన ఫంక్షన్స్ వేరు, ఈ ప్రోగ్రామింగ్ ఫంక్షన్స్ వేరు. కాన్సెప్ట్ ఒకటే అయినా, పనిచేసే విధానం వేరు. దీన్ని క్లియర్‌గా చూద్దాం.


## 10\. `return` ఎందుకు కన్ఫ్యూజ్‌గా ఉంటుంది? (అసలు కారణం)


### 10.1 మ్యాథ్స్‌లో ఏం జరుగుతుంది?


మ్యాథ్స్‌లో మనం ఇలా రాస్తాం:
$$f(x) = x^2$$


ఇక్కడ మనం "రిటర్న్" గురించి అస్సలు ఆలోచించం. ఎందుకు?
ఎందుకంటే అది ఒక **రూల్ (Rule)** మాత్రమే. ఒక మెషీన్ కాదు.


మనం $f(3)$ అని రాసినప్పుడు, మన మైండ్‌లో వెంటనే:
$$f(3) = 3^2 = 9$$


అని కాలిక్యులేట్ చేస్తాం. ఆ ఆన్సర్ (9) అక్కడ **ఆటోమేటిక్‌గా** వచ్చేస్తుంది.


 * అక్కడ మెమరీ లేదు.
 * ఎవరు అడిగారు? అని వెనక్కి ఇవ్వాల్సిన పని లేదు.
 * అది జస్ట్ ఒక కాన్సెప్ట్ మాత్రమే.


### 10.2 C లో ఏం జరుగుతుంది? (తేడా ఇదే)


కానీ C లాంగ్వేజ్‌లో, ఫంక్షన్ అనేది ఒక **బ్లాక్ ఆఫ్ కోడ్ (Block of code)**. అంటే కొన్ని ఇన్స్ట్రక్షన్స్ ఉన్న ఒక బాక్స్.


అందుకే ఇక్కడ ఏం జరుగుతుందంటే:


1. CPU ఆ ఫంక్షన్ లోపలికి వెళ్తుంది.
2. లైన్ బై లైన్ (Line-by-line) ఎగ్జిక్యూట్ చేస్తుంది.
3. చివరికి వచ్చాక దానికి తెలియాలి కదా: **"నేను ఏ వాల్యూని వెనక్కి తీసుకెళ్ళాలి? ఇప్పుడు నేను ఎక్కడికి వెళ్ళాలి?"**


అందుకే మనం `return` వాడతాం.


-----


## 11\. C లో `return` అంటే అసలు అర్థం ఏంటి?


### 11.1 సింపుల్‌గా చెప్పాలంటే


`return` స్టేట్‌మెంట్ ఒకేసారి రెండు పనులు చేస్తుంది:


1. వాల్యూని (Value) పిలిచిన వారికి (Caller) **వెనక్కి పంపిస్తుంది**.
2. ఫంక్షన్ ని అక్కడితో **ఆపేస్తుంది (Stop/Exit)**.


అంతే\! ఇందులో పెద్ద మ్యాజిక్ ఏం లేదు.


### 11.2 ఫంక్షన్ కాల్ ని ఒక "ప్రశ్న" లాగా చూడండి


ఈ లైన్ చూడండి:


```c
double y = square(3.0);
```


ఇది మామూలు లైన్ కాదు, ఇది ఒక **ప్రశ్న (Question)**:


> *"రేయ్ square, 3.0 ని తీసుకుని, దాన్ని స్క్వేర్ చేసి, వచ్చిన ఆన్సర్‌ని నాకు ఇవ్వు. నేను దాన్ని `y` లో దాచుకుంటా."*


ఇప్పుడు ఫంక్షన్ కోడ్ చూడండి:


```c
double square(double x) {
   return x * x;
}
```


ఎప్పుడైతే `return x * x;` రన్ అవుతుందో:


1. `x * x` కాలిక్యులేట్ అవుతుంది.
2. వచ్చిన ఆన్సర్, ఎవరైతే పిలిచారో (`main`) అక్కడికి వెళ్తుంది.
3. ఫంక్షన్ పని ఆగిపోతుంది.
4. కంట్రోల్ మళ్ళీ `main` కి వెళ్ళిపోతుంది.


So, ఎఫెక్టివ్‌గా ఏం జరుగుతుందంటే:
`double y = square(3.0);` $\rightarrow$ ఇలా మారుతుంది $\rightarrow$ `double y = 9.0;`


మ్యాథ్స్ లో వాల్యూని సబ్‌స్టిట్యూట్ (Substitution) చేయడం ఎలాగో, ప్రోగ్రామింగ్‌లో ఇది అలాగన్నమాట.


-----


## 12\. మ్యాథ్స్ $\rightarrow$ C (పోలిక చూద్దాం)


| ఫీచర్ | మ్యాథ్స్ (Maths) | C ప్రోగ్రామింగ్ (C Programming) |
| :--- | :--- | :--- |
| **డెఫినిషన్** | $f(x) = x^2$ | `double square(double x)` |
| **వాడకం** | $f(3)$ | `square(3.0)` |
| **రిజల్ట్** | ఆటోమేటిక్‌గా అక్కడ ఉంటుంది | కచ్చితంగా **మనమే రిటర్న్ చేయాలి** |
| **ఫ్లో (Flow)** | ఫ్లో అంటూ ఏం ఉండదు | పని అయ్యాక ఫంక్షన్ నుంచి **బయటకు రావాలి** |
| **డేటా టైప్** | టైప్స్ ఉండవు | రిటర్న్ టైప్ **ముందే చెప్పాలి** (int/float) |


మ్యాథ్స్‌లో "return" అనేది **Implicit** (ఆటోమేటిక్). C లో "return" అనేది **Explicit** (మనమే చెప్పాలి).


-----


## 13\. రిటర్న్ టైప్ ఎందుకు మ్యాచ్ అవ్వాలి?


### 13.1 కంపైలర్ ఎలా ఆలోచిస్తుంది?


మనం ఇలా రాసినప్పుడు:


```c
double square(double x);
```


కంపైలర్ నోట్ చేసుకుంటుంది:


 * **ఫంక్షన్ పేరు:** `square`
 * **తీసుకునేది (Input):** `double`
 * **ఇచ్చేది (Output):** `double`


సో, మీరు కింద ఇలా రాస్తే:


```c
int a = square(3.0);
```


కంపైలర్ వెంటనే చెక్ చేస్తుంది:


 * "అరే, `square` ఏమో `double` ఇస్తుంది."
 * "కానీ నువ్వేమో `int a` లో దాస్తానంటున్నావ్."


ఇది **Type Mismatch**. మ్యాథ్స్‌కి డేటా టైప్స్‌తో పనిలేదు, కానీ కంప్యూటర్ మెమరీకి ఉంటుంది కదా\! అందుకే C స్ట్రిక్ట్ గా ఉంటుంది.


-----


## 14\. `return` అంటే `printf` కాదు\!


స్టూడెంట్స్ చేసే అతి పెద్ద తప్పు ఇదే. బాగా గుర్తుపెట్టుకోండి.


```c
return x * x;
```


దీని అర్థం "స్క్రీన్ మీద ప్రింట్ చెయ్యి" అని **కాదు**.


దీని అర్థం: **"ఈ వాల్యూని, నన్ను పిలిచిన వాడికి వెనక్కి ఇవ్వు"** అని.


 * **Printing** అంటే జస్ట్ యూజర్‌కి చూపించడం (Side effect).
 * **Returning** అంటే డేటాని ప్రోగ్రామ్‌లో ఒక చోట నుంచి మరో చోటకి పంపడం (Data flow).


**తేడా చూడండి:**


```c
printf("%f", x * x);  // స్క్రీన్ మీద చూపిస్తుంది. ఆ తర్వాత ఆ వాల్యూని మర్చిపోతుంది.
return x * x;         // వాల్యూని main కి పంపిస్తుంది. దాన్ని మనం వేరే కాలిక్యులేషన్‌కి వాడుకోవచ్చు.
```


-----


## 15\. ఒక ఫంక్షన్‌లో ఎన్నైనా Returns ఉండొచ్చు, కానీ...


మ్యాథ్స్‌లో ఒక ఫంక్షన్‌కి ఒకటే ఆన్సర్ ఉంటుంది.
C లో, మనం ఎన్నైనా `return` స్టేట్‌మెంట్స్ రాయొచ్చు, కానీ **ఒక్కటి మాత్రమే రన్ అవుతుంది**. ఒక్కసారి `return` రన్ అయితే, ఫంక్షన్ అక్కడితో క్లోజ్ అయిపోతుంది.


**ఉదాహరణ:**


```c
int max2(int a, int b) {
   if (a > b)
       return a;  // ఇది రన్ అయితే, ఫంక్షన్ ఇక్కడితో ఆగిపోతుంది.
   else
       return b;  // లేదంటే, ఇది రన్ అవుతుంది.
}
```


దారులు (Paths) వేరైనా, వచ్చేది ఒక వాల్యూనే.


-----


## 16\. అసలు `void` ఫంక్షన్స్ ఎందుకు ఉన్నాయి?


మ్యాథ్స్‌లో ప్రతి ఫంక్షన్ ఏదో ఒక ఆన్సర్ ఇస్తుంది.
కానీ ప్రోగ్రామింగ్‌లో, కొన్నిసార్లు మనం జస్ట్ **పని జరగడానికి** ఫంక్షన్ రాస్తాం. ఆన్సర్ కోసం కాదు.
ఉదాహరణకు:


 * మెనూ ప్రింట్ చేయడానికి.
 * స్క్రీన్ క్లియర్ చేయడానికి.
 * ఫైల్‌లో డేటా రాయడానికి.


**ఉదాహరణ:**


```c
void greet(void) {
   printf("Hello!\n");
   // ఇక్కడ return అవసరం లేదు. పని అయ్యాక అదే వెనక్కి వెళ్ళిపోతుంది.
}
```


ఇక్కడ:


 * వెనక్కి ఇవ్వడానికి వాల్యూ ఏం లేదు.
 * ఫంక్షన్ పని కేవలం **ప్రింట్ చేయడం**.
 * అందుకే `void` (శూన్యం) వాడతాం.


ఇలాంటి ఫంక్షన్ నుంచి వాల్యూ ఆశించడం (`int x = greet();`) తప్పు.


-----


## 17\. Return విషయంలో చేసే కామన్ తప్పులు


**తప్పు 1: Return తర్వాత కోడ్ రాయడం**


```c
return x;
printf("Done"); // ఈ లైన్ అస్సలు రన్ అవ్వదు. వేస్ట్.
```


**తప్పు 2: Return వాల్యూని గాలికి వదిలేయడం**


```c
square(5); // 25 అని కాలిక్యులేట్ అయ్యింది, వెనక్కి వచ్చింది, కానీ దాన్ని ఎవరూ పట్టుకోలేదు (Store చేయలేదు). అది వేస్ట్ అయిపోతుంది.
```


*కరెక్ట్:* `int result = square(5);`


**తప్పు 3: లాజిక్ ప్రకారం తప్పు టైప్ ని రిటర్న్ చేయడం**


```c
int get_grade() {
   return 'A'; // 'A' అంటే 65 (ASCII). టెక్నికల్ గా కరెక్టే కానీ, లాజిక్ ప్రకారం కన్ఫ్యూజింగ్ గా ఉంటుంది.
}
```


**తప్పు 4: Return చేస్తే ఆర్గ్యుమెంట్ మారుతుందని అనుకోవడం**


```c
int f(int x) {
   x = 10;
   return x;
}
```


ఇక్కడ `x` మారితే అది ఫంక్షన్ లోపల మాత్రమే. `main` లోని ఒరిజినల్ వేరియబుల్ మారదు.


-----


## 18\. ఫైనల్ గా ఇలా గుర్తుపెట్టుకోండి (మెంటల్ మోడల్)


ఒక C ఫంక్షన్‌ని ఒక **మెషీన్ (Machine)** లా అనుకోండి:


1. ఇది **ఇన్‌పుట్స్** (Arguments) తీసుకుంటుంది.
2. లోపల ఏదో పని (Body) చేస్తుంది.
3. చివరికి **ఒకే ఒక వాల్యూని** యజమానికి (Caller) చేతిలో పెడుతుంది (Return).
4. షటర్ క్లోజ్ చేసుకుని ఆగిపోతుంది.


ఆ వాల్యూని చేతిలో పెట్టి, షటర్ క్లోజ్ చేయడమే **`return`** స్టేట్‌మెంట్.


-----


### 19\. స్టూడెంట్స్ కోసం ఒక్క మాటలో...


> **మ్యాథ్స్‌లో ఆన్సర్ ఆటోమేటిక్‌గా 'అక్కడ ఉంటుంది'. కానీ C లో, "ఇదిగో ఆన్సర్, తీసుకో" అని ప్రోగ్రామ్‌కి చెప్పడమే `return`.**

