


#  ప్రాక్టికల్ గా స్ట్రక్చర్స్ (Structures in Practice)


**(రియల్ లైఫ్ ఉదాహరణలు $\rightarrow$ ఫంక్షన్స్ తో స్ట్రక్చర్స్ $\rightarrow$ టైం (Time) లెక్కలు $\rightarrow$ కామన్ తప్పులు)**


## 1\. స్టూడెంట్ డేటా కోసం `union` ఎందుకు పనికిరాదు?


మనం ఒక రియల్ లైఫ్ అవసరాన్ని తీసుకుందాం:


> **"నాకు ఒక స్టూడెంట్ వివరాలు స్టోర్ చేయాలి, వాటితో కొన్ని పనులు (Operations) చేయాలి."**


ఒక స్టూడెంట్ కి ఏముంటాయి?


 * రోల్ నంబర్ (Integer)
 * మార్కులు (Float)
 * గ్రేడ్ (Character)


ఇక్కడ పాయింట్ ఏంటంటే:


1. ఇవన్నీ **కలిసి ఉండాలి**.
2. అన్నీ **ఒకేసారి మనకు కావాలి**.
3. అన్నింటినీ **కలిపే ప్రాసెస్ చేయాలి**.


### 1.1 `union` వాడితే వచ్చే తిప్పలు


మనం పొరపాటున `union` వాడాం అనుకోండి:


```c
union Student {
   int roll;
   float marks;
   char grade;
};
```


ఇప్పుడు మనం ఇలా రాస్తే:


```c
s.roll = 10;
s.marks = 82.5;
```


**ఏం జరుగుతుంది?**


 * `marks` వచ్చి `roll` ప్లేస్ లో కూర్చుంటుంది (`roll` ఓవర్ రైట్ అవుతుంది).
 * రోల్ నంబర్ డిలీట్ అయిపోతుంది.
 * ఇక దాన్ని "స్టూడెంట్" అని పిలవడంలో అర్థం లేదు.


 **ముగింపు:** స్టూడెంట్ డేటా అనేది "ఏదో ఒకటే ఉండాలి" అనే టైప్ కాదు. అన్నీ ఉండాలి. అందుకే `union` పనికిరాదు. అందుకే మనం **Structures** వాడతాం.


-----


## 2\. స్టూడెంట్ కోసం స్ట్రక్చర్ ని డిఫైన్ చేయడం


### 2.1 స్ట్రక్చర్ డెఫినిషన్ (బ్లూప్రింట్)


```c
struct Student {
   int roll;
   float marks;
   char grade;
};
```


**అర్థం:** *"స్టూడెంట్ అంటే రోల్ నంబర్, మార్క్స్, గ్రేడ్... ఇవన్నీ కలిసున్న ఒక మనిషి."*


**ఈ స్టేజ్ లో:** ఇంకా మెమరీ అలకేట్ అవ్వలేదు. ఇది జస్ట్ ప్లాన్ (Blueprint) మాత్రమే.


-----


## 3\. స్టూడెంట్ వేరియబుల్ ని క్రియేట్ చేయడం


```c
struct Student s1;
```


**అర్థం:** *"ఒక స్టూడెంట్ రికార్డ్ ని క్రియేట్ చెయ్యి. అందులో రోల్ నంబర్ కి, మార్క్స్ కి, గ్రేడ్ కి వేరు వేరుగా మెమరీ ఇవ్వు."*


**మెమరీ ఇలా ఉంటుంది (ఊహించుకోండి):**
`| roll | marks | grade |` (అన్నీ పక్కపక్కన సేఫ్ గా ఉంటాయి).


-----


## 4\. డేటాని నింపడం (Initialization)


```c
s1.roll = 101;
s1.marks = 86.5;
s1.grade = 'A';
```


మనం ఒకదానికి వాల్యూ ఇస్తే, పక్కదానికి ఏమీ అవ్వదు. అన్నీ సేఫ్.


-----


## 5\. స్ట్రక్చర్స్ తో ఫంక్షన్స్ రాయడం


ఇక్కడే స్ట్రక్చర్స్ యొక్క పవర్ తెలుస్తుంది. మామూలుగా అయితే ఫంక్షన్ కి చాలా వేరియబుల్స్ పంపాలి. కానీ స్ట్రక్చర్ వాడితే, **మొత్తం స్టూడెంట్ ని ఒకే పార్శిల్ లాగా** పంపొచ్చు.


### 5.1 ఫంక్షన్ 1: స్టూడెంట్ వివరాలు ప్రింట్ చేయడం


**పూర్తి ప్రోగ్రామ్:**


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
   char grade;
};


// ఫంక్షన్ మొత్తం స్టూడెంట్ ని తీసుకుంటుంది
void printStudent(struct Student s) {
   printf("Roll: %d\n", s.roll);
   printf("Marks: %.2f\n", s.marks);
   printf("Grade: %c\n", s.grade);
}


int main(void) {
   struct Student s1;


   s1.roll = 101;
   s1.marks = 86.5;
   s1.grade = 'A';


   printStudent(s1);


   return 0;
}
```


**వివరణ:**


 * `struct Student s` $\rightarrow$ ఫంక్షన్ కి స్టూడెంట్ డేటా మొత్తం ఒక కాపీ లాగా వెళ్తుంది.
 * ఫంక్షన్ లోపల, మనం డాట్ (`.`) ఆపరేటర్ వాడి వాటిని వాడుకుంటాం.
 * దీనివల్ల కోడ్ చదవడానికి చాలా బాగుంటుంది.


 **ముఖ్యమైన పాయింట్:** మనం కేవలం వాల్యూస్ పంపట్లేదు, ఒక **అర్థవంతమైన డేటాని (Meaningful Data)** పంపుతున్నాం.


### 5.2 విడివిడిగా పంపితే ఏమవుతుంది?


స్ట్రక్చర్ లేకపోతే ఫంక్షన్ ఇలా రాయాలి:


```c
void printStudent(int roll, float marks, char grade);
```


**సమస్యలు:**


1. ఆర్డర్ మారిపోవచ్చు (`int` బదులు `float` పంపే ఛాన్స్ ఉంది).
2. చూడటానికి బాగోదు.
3. రేపు కొత్తగా "Name" యాడ్ చేయాలంటే, అన్ని ఫంక్షన్స్ మార్చాలి.


స్ట్రక్చర్ వాడితే ఈ తలకాయనొప్పులు ఉండవు.


-----


## 6\. మరొక ఉదాహరణ: గడియారం టైం (Time)


ఇప్పుడు మరో రియల్ లైఫ్ ఉదాహరణ చూద్దాం: **"మనం టైం (Time) ని స్టోర్ చేయాలి."**


టైం లో ఏముంటాయి?


 * గంటలు (Hours)
 * నిమిషాలు (Minutes)


ఇవి రెండూ కలిసే ఉంటాయి. టైం పోల్చాలన్నా, తీసివేయాలన్నా రెండూ కావాలి. దీనికి స్ట్రక్చర్ పర్ఫెక్ట్.


-----


## 7\. Time Structure ని డిఫైన్ చేయడం


```c
struct Time {
   int hour;
   int minute;
};
```


**అర్థం:** *"టైం అంటే ఒక గంట మరియు ఒక నిమిషం."*


-----


## 8\. ఫంక్షన్: టైం ని నీట్ గా ప్రింట్ చేయడం


```c
#include <stdio.h>


struct Time {
   int hour;
   int minute;
};


void printTime(struct Time t) {
   // %02d అంటే రెండు అంకెలు వచ్చేలా ప్రింట్ చెయ్యమని (ఉదా: 09:05)
   printf("%02d:%02d\n", t.hour, t.minute);
}


int main(void) {
   struct Time t1;


   t1.hour = 9;
   t1.minute = 5;


   printTime(t1);


   return 0;
}
```


**వివరణ:** గంటలు, నిమిషాలు ఒకే బాక్స్ లో ఉన్నాయి. ఫంక్షన్ ఆ బాక్స్ ని తీసుకుని నీట్ గా ప్రింట్ చేసింది.


-----


## 9\. ఫంక్షన్: టైం ని మొత్తం నిమిషాల్లోకి మార్చడం


టైం ని పోల్చాలంటే (Compare) లేదా తీసివేయాలంటే (Subtract), గంటలు-నిమిషాలు అని చూస్తే కష్టం. మొత్తం నిమిషాల్లోకి మార్చేస్తే పని ఈజీ అవుతుంది.
**ఐడియా:** *"రాత్రి 12 గంటల నుండి ఎన్ని నిమిషాలు అయ్యింది?"*


```c
#include <stdio.h>


struct Time {
   int hour;
   int minute;
};


int toMinutes(struct Time t) {
   return t.hour * 60 + t.minute;
}


int main(void) {
   struct Time t;
   t.hour = 2;
   t.minute = 30;


   printf("Total minutes = %d\n", toMinutes(t));
   return 0;
}
```


**వివరణ:** ఒక స్ట్రక్చర్ ని తీసుకున్నాం $\rightarrow$ ఒక ఇంటిజర్ (మొత్తం నిమిషాలు) ని ఇచ్చాం. లెక్క చాలా సింపుల్ అయిపోయింది.


-----


## 10\. ఫంక్షన్: రెండు టైముల మధ్య తేడా (Difference)


ఇప్పుడు ఒక పెద్ద సమస్యను సాల్వ్ చేద్దాం: **"రెండు టైముల మధ్య ఎంత తేడా ఉందో నిమిషాల్లో చెప్పాలి."**


**పూర్తి ప్రోగ్రామ్:**


```c
#include <stdio.h>


struct Time {
   int hour;
   int minute;
};


// సహాయక ఫంక్షన్ (Helper Function)
int toMinutes(struct Time t) {
   return t.hour * 60 + t.minute;
}


// అసలు లాజిక్
int timeDifference(struct Time t1, struct Time t2) {
   int m1 = toMinutes(t1);
   int m2 = toMinutes(t2);
   return m2 - m1;
}


int main(void) {
   struct Time start, end;


   start.hour = 10;
   start.minute = 15;


   end.hour = 12;
   end.minute = 45;


   printf("Difference = %d minutes\n", timeDifference(start, end));


   return 0;
}
```


**వివరణ (చాలా ముఖ్యం):**


1. ప్రతి `Time` ఒక పూర్తి ఎంటిటీ.
2. రెండింటినీ మనం ఒకే కొలమానంలోకి (నిమిషాల్లోకి) మార్చేసాం.
3. తీసివేయడం చాలా ఈజీ అయిపోయింది.
4. డేటా ఫ్లో చాలా క్లియర్ గా ఉంది.


 **పోలిక:**


 * స్ట్రక్చర్ తో: `timeDifference(start, end);` (చదవగానే అర్థమవుతుంది).
 * స్ట్రక్చర్ లేకపోతే: `timeDifference(h1, m1, h2, m2);` (చాలా గందరగోళం).


-----


## 11\. స్ట్రక్చర్స్ వల్ల ఫంక్షన్స్ ఎందుకు బాగుంటాయి?


స్ట్రక్చర్స్ వాడితే:


1. ఫంక్షన్స్ కి **ఒక్క** పారామీటర్ పంపితే చాలు.
2. అర్థం (**Meaning**) మారదు.
3. **తప్పులు** తగ్గుతాయి.
4. కోడ్ చదువుతుంటే రియల్ లైఫ్ లాజిక్ లా అనిపిస్తుంది.


-----


##  ఫంక్షన్స్ రాసేటప్పుడు చేసే కామన్ తప్పులు


**సూచన:** `❌` గుర్తు ఉన్న లైన్ లో తప్పు ఉంది. దాని కింద ఉన్న వివరణ చదవండి.


###  Mistake 1: స్ట్రక్చర్ బదులు విడివిడి ముక్కలు పంపడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


void printStudent(int r, float m) {   // ❌ అనవసరంగా విడగొట్టాం
   printf("Roll: %d, Marks: %.2f\n", r, m);
}


int main(void) {
   struct Student s;
   s.roll = 101;
   s.marks = 85.5;


   printStudent(s.roll, s.marks);    // ❌ స్ట్రక్చర్ ఉద్దేశం పోయింది
   return 0;
}
```


**వివరణ:** ఈ ఫంక్షన్ ఇక "Student" తో పని చేయట్లేదు, వేరు వేరు నంబర్లతో పని చేస్తోంది. గ్రూపింగ్ మిస్ అయ్యింది. రేపు స్టూడెంట్ లో కొత్త ఫీల్డ్ యాడ్ అయితే అన్ని ఫంక్షన్స్ మార్చాలి.
 **కరెక్ట్ పద్ధతి:** స్ట్రక్చర్ ని మొత్తం ఒకేసారి పంపండి (`struct Student s`).


### Mistake 2: ఫంక్షన్ లో మారిస్తే బయట మారుతుందనుకోవడం


```c
#include <stdio.h>


struct Student {
   int roll;
};


void changeRoll(struct Student s) {
   s.roll = 200;     // ❌ కేవలం లోకల్ కాపీ మారుతుంది
}


int main(void) {
   struct Student s;
   s.roll = 100;


   changeRoll(s);
   printf("%d\n", s.roll);   // స్టిల్ 100 గానే ఉంటుంది
   return 0;
}
```


**వివరణ:** మనం స్ట్రక్చర్ ని పంపినప్పుడు, ఫంక్షన్ కి ఒక **కాపీ (Xerox)** వెళ్తుంది. జిరాక్స్ లో మార్పులు చేస్తే ఒరిజినల్ మారదు కదా\! ఇది కూడా అంతే.
 **గుర్తుపెట్టుకోండి:** స్ట్రక్చర్ ని పంపితే కాపీ వెళ్తుంది (Call by Value). మార్చాలంటే పాయింటర్స్ కావాలి (అది తర్వాత చూద్దాం).


###  Mistake 3: ఫంక్షన్ లో `struct` కీవర్డ్ మర్చిపోవడం


```c
void printStudent(Student s) {  // ❌ C లో ఇది తప్పు
   // ...
}
```


**వివరణ:** C లాంగ్వేజ్ లో `Student` అనేది డేటా టైప్ కాదు. `struct Student` అనేది డేటా టైప్. C++ అలవాటు ఉన్నవాళ్ళు ఈ తప్పు చేస్తారు.


###  Mistake 4: ఫంక్షన్ లోపల మెంబర్స్ ని తప్పుగా పిలవడం


```c
void printTime(struct Time t) {
   printf("%d:%d\n", hour, minute);  // ❌ ఎవరి hour? ఎవరి minute?
}
```


**వివరణ:** `hour`, `minute` గాలిలో ఉండవు. అవి `t` అనే స్ట్రక్చర్ లోపల ఉన్నాయి. కాబట్టి `t.hour`, `t.minute` అని కచ్చితంగా చెప్పాలి.


###  Mistake 5: స్ట్రక్చర్ ని ఎరే లాగా ట్రీట్ చేయడం


```c
void printData(struct Data d) {
   printf("%d\n", d[0]);   // ❌ స్ట్రక్చర్ కి ఇండెక్స్ ఉండదు
}
```


**వివరణ:** స్ట్రక్చర్ అనేది కలెక్షన్ కాదు. దానికి పేర్లు (Names) ఉంటాయి, ఇండెక్స్ లు ఉండవు. `d.a`, `d.b` అని పిలవాలి.


###  Mistake 6: ఆర్డర్ చూసుకోకుండా ఇనిషియలైజ్ చేయడం


```c
struct Student s = {85.5, 101};  // ❌ తప్పు ఆర్డర్
```


**వివరణ:** స్ట్రక్చర్ లో `int roll` ముందు ఉంది, తర్వాత `float marks` ఉంది. మనం రివర్స్ లో ఇస్తే డేటా తప్పుగా వెళ్తుంది. కంపైలర్ వార్నింగ్ ఇవ్వకపోవచ్చు, కానీ లాజిక్ తప్పు అవుతుంది.


###  Mistake 7: అనవసరంగా ఎక్కువ ఫంక్షన్స్ రాయడం


```c
void printRoll(int r);
void printMarks(float m);
void printGrade(char g);   // ❌ ముక్కలు ముక్కలు చేయడం
```


**వివరణ:** స్ట్రక్చర్ ఉద్దేశమే డేటాని కలపడం. ఇలా విడగొట్టి రాస్తే స్ట్రక్చర్ వాడి ఉపయోగం లేదు.
**కరెక్ట్ పద్ధతి:** ఒక స్ట్రక్చర్ $\rightarrow$ ఒక మీనింగ్ ఫుల్ ఫంక్షన్.


### Mistake 8: పారామీటర్ కాపీ అని మర్చిపోవడం


```c
void normalize(struct Time t) {
   // టైం ని సరిచేసే లాజిక్...
   // ఇక్కడ చేసిన మార్పులు ఫంక్షన్ అయిపోగానే పోతాయి! ❌
}
```


**వివరణ:** `t` అనేది లోకల్ కాపీ. అందులో మార్పులు చేస్తే మెయిన్ ప్రోగ్రామ్ కి తెలియదు.


-----


## 12\. ఫైనల్ గా ఈ చాప్టర్ సారాంశం


ఇప్పటికి మీకు ఈ విషయాలపై ఫుల్ క్లారిటీ రావాలి:


1. స్టూడెంట్ లేదా టైం వంటి వాటికి `union` ఎందుకు పనికిరాదో.
2. `struct` అనేది ఎలా కరెక్ట్ గా సెట్ అవుతుందో.
3. రిలేటెడ్ డేటాని ఎలా గ్రూప్ చేయాలో.
4. ఫంక్షన్స్ స్ట్రక్చర్స్ తో ఎంత బాగా పనిచేస్తాయో.
5. రియల్ లైఫ్ సమస్యలని స్ట్రక్చర్ డేటాగా ఎలా మార్చాలో.


**ఒక్క ముక్కలో చెప్పాలంటే:**


> **స్ట్రక్చర్స్ వల్ల మనం ప్రోగ్రామ్ ని కేవలం వేరియబుల్స్ లా కాకుండా, రియల్ లైఫ్ ఆబ్జెక్ట్స్ (వస్తువులు/మనుషులు) లాగా ఆలోచించి రాయగలం.**



