


#  C లో `union`


**(Definition $\rightarrow$ Memory $\rightarrow$ Usage $\rightarrow$ Pitfalls $\rightarrow$ Arrays $\rightarrow$ Pointers $\rightarrow$ Call by Reference $\rightarrow$ Closure)**


## 1\. తెలిసిన దానితో మొదలుపెడదాం: సాధారణ వేరియబుల్


`union` గురించి తెలుసుకునే ముందు, మనకు ఆల్రెడీ తెలిసిన దానితో స్టార్ట్ చేద్దాం.


### 1.1 సాధారణ వేరియబుల్ ని డిఫైన్ చేయడం


```c
int x;
```


దీని అర్థం ఏంటి?


 * `int` $\rightarrow$ **built-in datatype keyword**
     * కంపైలర్ కి ఏం చెప్తుందంటే: *"ఒక ఇంటిజర్ ని దాచడానికి సరిపడా మెమరీని రిజర్వ్ చెయ్యి."*
 * `x` $\rightarrow$ **variable name**
     * ఆ మెమరీ లొకేషన్ కి మనం పెట్టుకున్న పేరు (Label).


సో ఈ లైన్ అర్థం:


> **"ఒక ఇంటిజర్ పట్టేంత ఒక మెమరీ బాక్స్ ని క్రియేట్ చేసి, దానికి `x` అని పేరు పెట్టు."**


ఇప్పుడు:


```c
x = 10;
```


దీని అర్థం:


> **"`x` అనే పేరున్న మెమరీ బాక్స్ లో 10 అనే వాల్యూని పెట్టు."**


### 1.2 ముఖ్యమైన విషయం


`x` కి మూడు ఉంటాయి:


1. ఒక డేటా టైప్ (int)
2. ఒక సైజు (size)
3. ఒక మెమరీ అడ్రస్ (address)


**ముఖ్యంగా:** `x` ఆ మెమరీని **ఒకే రకంగా** (ఇంటిజర్ లా మాత్రమే) వాడుకోగలదు. మనకు ఒకే రకమైన డేటా చాలు అనుకున్నప్పుడు ఇది ఓకే.


-----


## 2\. ఈ పద్ధతి ఎక్కడ ఫెయిల్ అవుతుంది? (Union ఎందుకు కావాలి?)


ఇప్పుడు ఈ అవసరం వచ్చింది అనుకోండి:


> **"నాకు ఒక వేరియబుల్ కావాలి. అందులో నేను ఇంటిజర్ గానీ, ఫ్లోట్ గానీ, క్యారెక్టర్ గానీ దాచుకుంటాను. కానీ ఎప్పుడూ మూడూ ఒకేసారి కాదు. ఏదో ఒక్కటే దాచుకుంటాను."**


మామూలుగా అయితే మనం ఇలా రాస్తాం:


```c
int i;
float f;
char c;
```


**సమస్యలు:**


1. మూడు వేర్వేరు మెమరీ బాక్సులు క్రియేట్ అవుతాయి.
2. కానీ మనం ఎప్పుడూ ఏదో ఒక్క దాన్నే వాడుకుంటాం.
3. **మిగతా రెండు బాక్సుల మెమరీ వేస్ట్ అవుతుంది.**


కాబట్టి మనకు ఏం కావాలి?


> **"ఈ మూడు వేరియబుల్స్ ఒకే మెమరీని పంచుకోవాలి (Reuse)."**


సరిగ్గా దీని కోసమే **union** వచ్చింది.


-----


## 3\. అసలు `union` అంటే ఏంటి? (Core Definition)


> **Union అనేది మనం క్రియేట్ చేసుకునే డేటా టైప్ (User-defined datatype). ఇందులో ఉండే మెంబర్స్ అందరూ ఒకే మెమరీ లొకేషన్ ని పంచుకుంటారు (Share).**


ఈ ఒక్క ముక్క అర్థమైతే యూనియన్ మొత్తం అర్థమైనట్టే.


-----


## 4\. Union ని డిఫైన్ చేయడం — లైన్-బై-లైన్ వివరణ


### 4.1 Union Definition (బ్లూప్రింట్ దశ)


```c
union Data {
   int i;
   float f;
   char c;
};
```


ప్రతి పదాన్ని విడదీసి చూద్దాం.


**Line 1:** `union Data {`


 * `union` $\rightarrow$ **keyword**. కంపైలర్ కి చెప్తుంది: *"నేను ఒక యూనియన్ ని డిఫైన్ చేస్తున్నా."*
 * `Data` $\rightarrow$ **యూనియన్ పేరు**. `int`, `float` లాగే ఇదొక పేరు.
 * `{` $\rightarrow$ **లిస్ట్ మొదలు**.


 **ముఖ్యమైన విషయం:** ఇక్కడ ఇంకా **మెమరీ అలకేట్ అవ్వలేదు.** మనం కేవలం రూల్ రాసాం (Blueprint), ఇల్లు కట్టలేదు.


**Line 2:** `int i;`


 * **అర్థం:** *"ఈ యూనియన్ తన మెమరీని `i` అనే పేరుతో ఇంటిజర్ లాగా వాడుకోగలదు."*


**Line 3:** `float f;`


 * **అర్థం:** *"అదే మెమరీని `f` అనే పేరుతో ఫ్లోట్ లాగా కూడా వాడుకోగలదు."*


**Line 4:** `char c;`


 * **అర్థం:** *"అదే మెమరీని `c` అనే పేరుతో క్యారెక్టర్ లాగా కూడా వాడుకోగలదు."*


**Line 5:** `};`


 * డెఫినిషన్ ముగిసింది. **సెమీకోలన్ (;) ఖచ్చితంగా పెట్టాలి.**


### 4.2 ఇది స్టూడెంట్స్ కి బాగా ఎక్కాలి


యూనియన్ కి **ఒక్కటే** మెమరీ బాక్స్ ఉంటుంది. కానీ దానికి **మల్టిపుల్** పేర్లు (Labels) ఉంటాయి.


> **ఒకే టైంలో ఏదో ఒక్క రూపం (Interpretation) మాత్రమే వాలిడ్ గా ఉంటుంది.**


-----


## 5\. Union Variable ని డిక్లేర్ చేయడం (మెమరీ అలకేషన్)


ఈ రెండిటి మధ్య తేడా చూడండి.


**Normal variable:**


```c
int x;
```


 * వెంటనే మెమరీ బుక్ అవుతుంది.
 * సైజు = `int` సైజు.


**Union variable:**


```c
union Data d;
```


 * **అర్థం:** *"యూనియన్ Data లో ఉన్న మెంబర్స్ అందరిలోకెల్లా పెద్దది ఎవరో చూసి, దానికి సరిపోయేంత **ఒకే ఒక మెమరీ బాక్స్** ని క్రియేట్ చెయ్యి. దాని పేరు `d`."*


-----


## 6\. Union సైజు ఎంత? (మెమరీ ఎలా ఆదా అవుతుంది?)


```c
union Data {
   int i;    // 4 bytes
   float f;  // 4 bytes
   char c;   // 1 byte
};
```


**మొత్తం సైజు:**


 * $4 + 4 + 1$ **కాదు**.
 * $\max(4, 4, 1) = 4$ bytes **మాత్రమే**.


**ఎందుకు?**


1. మెంబర్స్ అందరూ ఒకే ప్లేస్ లో కూర్చుంటారు.
2. ఒకే టైంలో ఒక్కరే ఉంటారు కాబట్టి, అందరిలో పెద్దవాడి సైజు ఉంటే చాలు.


-----


## 7\. Union ని ఎలా వాడాలి?


### 7.1 వాల్యూస్ ఇవ్వడం


```c
d.i = 10;
```


 * **అర్థం:** *"ఆ మెమరీని ఇంటిజర్ లాగా ట్రీట్ చేసి 10 ని స్టోర్ చెయ్యి."*


తర్వాత:


```c
d.f = 3.14f;
```


 * **అర్థం:** *"అదే మెమరీని ఇప్పుడు ఫ్లోట్ లాగా ట్రీట్ చేసి 3.14 ని స్టోర్ చెయ్యి."*


 **పాత ఇంటిజర్ వాల్యూ ఎగిరిపోతుంది (Overwrite).** ఇది ఎర్రర్ కాదు, యూనియన్ లక్షణమే అంత.


-----


## 8\. Dot (`.`) Operator


డాట్ ఆపరేటర్ అంటే:


> **"ఒక గ్రూప్ (Composite datatype) లోపల ఉన్న మెంబర్ ని యాక్సెస్ చేయడం."**


**ఉదాహరణలు:**


 * `d.i`
 * `d.f`
 * `d.c`


**దీని అర్థం:** *"`d` అనే యూనియన్ లోపల ఉన్న `i` అనే మెంబర్."*
మామూలు వేరియబుల్స్ (`x`) కి లోపల మెంబర్స్ ఉండరు కాబట్టి డాట్ వాడలేం.


-----


## 9\. మొదటి పూర్తి ప్రోగ్రామ్ (Observation)


```c
#include <stdio.h>


union Data {
   int i;
   float f;
   char c;
};


int main(void) {
   union Data d;


   // ఇంటిజర్ ని స్టోర్ చేసాం
   d.i = 10;
   printf("i = %d\n", d.i);


   // ఫ్లోట్ ని స్టోర్ చేసాం (పాత ఇంటిజర్ పోతుంది)
   d.f = 3.14f;
   printf("f = %f\n", d.f);


   // క్యారెక్టర్ ని స్టోర్ చేసాం (పాత ఫ్లోట్ పోతుంది)
   d.c = 'A';
   printf("c = %c\n", d.c);


   return 0;
}
```


**కాన్సెప్ట్ రీడింగ్:**


1. ఒక మెమరీ బాక్స్ క్రియేట్ అయ్యింది.
2. ఇంటిజర్ ని పెట్టాం.
3. అదే బాక్స్ ని ఫ్లోట్ కోసం వాడుకున్నాం.
4. అదే బాక్స్ ని క్యారెక్టర్ కోసం వాడుకున్నాం.


-----


## 10\. `union` వల్ల నష్టాలు (Disadvantages)


1. **ఒకేసారి ఒక్క మెంబర్** మాత్రమే ఉంటుంది.
2. ప్రస్తుతం ఏ మెంబర్ యాక్టివ్ గా ఉందో చెప్పడానికి **ట్రాకింగ్ ఉండదు**.
3. మనం తప్పు మెంబర్ ని యాక్సెస్ చేసినా కంపైలర్ **వార్నింగ్ ఇవ్వదు** (లాజిక్ ఎర్రర్ వస్తుంది).
4. బిగినర్స్ కి అర్థం చేసుకోవడం కొంచెం కష్టం.
5. అందరి డేటా ఒకేసారి కావాలంటే (ఉదాహరణకు స్టూడెంట్ రికార్డ్) ఇది పనికిరాదు.


-----


## 11\. సాధారణ తప్పులు (Common Mistakes)


`❌` ఉన్న లైన్ లో తప్పు ఉందని అర్థం.


###   Mistake 1: అందరూ ఒకేసారి ఉంటారనుకోవడం


```c
#include <stdio.h>


union Data {
   int i;
   float f;
};


int main(void) {
   union Data d;
   d.i = 10;
   d.f = 2.5f;            // d.i ని ఓవర్ రైట్ చేస్తుంది
   printf("%d\n", d.i);   // ❌ గార్బేజ్ వాల్యూ లేదా తప్పు వాల్యూ వస్తుంది
   return 0;
}
```


**వివరణ:** `d.f` పెట్టినప్పుడు, `d.i` ఉన్న మెమరీనే వాడుకుంటుంది. సో పాతది ఉండదు.


### Mistake 2: స్ట్రక్చర్ వాడాల్సిన చోట యూనియన్ వాడటం


```c
#include <stdio.h>


union Student {
   int roll;
   float marks;
};


int main(void) {
   union Student s;
   s.roll = 1;
   s.marks = 90.0f;                        // రోల్ నంబర్ పోతుంది
   printf("%d %.2f\n", s.roll, s.marks);   // ❌ రోల్ నంబర్ రాదు
   return 0;
}
```


**వివరణ:** ఒక స్టూడెంట్ కి రోల్ నంబర్ **మరియు** మార్క్స్ రెండూ ఒకేసారి ఉండాలి. యూనియన్ ఏదో ఒకటే ఉంచుతుంది. ఇది లాజిక్ ప్రకారం తప్పు.


### Mistake 3: `union` కీవర్డ్ మర్చిపోవడం


```c
union Data {
   int i;
};


int main(void) {
   Data d;   // ❌ కంపైలర్ కి 'Data' అంటే ఏంటో తెలియదు
   return 0;
}
```


**వివరణ:** మనం `union Data d;` అని రాయాలి.


-----


## 12\. Union ఒక User-Defined Datatype (చాలా ముఖ్యం)


ఎలాగైతే:


```c
int x;
```


రాస్తామో, అలాగే:


```c
union Data d;
```


రాయొచ్చు.


సో:


1. `union Data` అనేది ఒక **డేటా టైప్**.
2. `d` అనేది ఒక **వేరియబుల్**.
3. `d` కి ఒక **సైజు, మెమరీ, మరియు అడ్రస్** ఉంటాయి.


దీని అర్థం ఏంటంటే:


> **ఒక పాయింటర్ `int` ని పాయింట్ చేసినట్టే, ఒక యూనియన్ ని కూడా పాయింట్ చేయగలదు.**


-----


## 13\. Pointers మరియు Union (కలిసి ఎలా పనిచేస్తాయి?)


```c
union Data d;
union Data *p = &d;
```


 * `p` లో `d` యొక్క **అడ్రస్** ఉంటుంది.
 * `p->i` అని రాస్తే, పాయింటర్ ద్వారా మెంబర్ `i` ని యాక్సెస్ చేయొచ్చు.


-----


## 14\. Call by Reference with Union (వివరంగా)


**కీ పాయింట్:**
యూనియన్ కి మెమరీ, అడ్రస్ ఉన్నాయి కాబట్టి, మనం దాన్ని పాయింటర్ ద్వారా ఫంక్షన్ కి పంపొచ్చు (Pass by reference).


### పూర్తి ప్రోగ్రామ్: యూనియన్ ని రెఫరెన్స్ ద్వారా పంపడం


```c
#include <stdio.h>


union Data {
   int i;
   float f;
};


void update(union Data *u) {
   u->i = 100;
}


int main(void) {
   union Data d;


   d.i = 20;
   update(&d);
   printf("After update: %d\n", d.i);


   return 0;
}
```


**లైన్-బై-లైన్ వివరణ:**


1. `union Data *u` $\rightarrow$ యూనియన్ అడ్రస్ ని తీసుకోగలిగే పాయింటర్.
2. `update(&d)` $\rightarrow$ `d` యొక్క అడ్రస్ ని పంపుతున్నాం.
3. `u->i = 100;` $\rightarrow$ `d` ఉన్న మెమరీకి వెళ్ళు $\rightarrow$ దాన్ని ఇంటిజర్ అనుకో $\rightarrow$ ఒరిజినల్ వాల్యూని మార్చు.


ఇది అచ్చం `int` తో చేసినట్టే, కాకపోతే ఇప్పుడు ఒక యూనియన్ తో చేస్తున్నాం.


-----


## 15\. Arrays of Union (యూనియన్ల ఎరే)


### 15.1 యూనియన్ ఎరే ని డిఫైన్ చేయడం


```c
union Data arr[3];
```


**అర్థం:**


> **"3 యూనియన్ వేరియబుల్స్ ని వరుసగా క్రియేట్ చెయ్యి. ఒక్కో దానికి దాని సొంత మెమరీ బాక్స్ ఉంటుంది."**


### పూర్తి ఉదాహరణ


```c
#include <stdio.h>


union Data {
   int i;
   float f;
};


int main(void) {
   union Data arr[3];


   arr[0].i = 10;     // 0వ ఎలిమెంట్ లో int
   arr[1].f = 2.5f;   // 1వ ఎలిమెంట్ లో float
   arr[2].i = 30;     // 2వ ఎలిమెంట్ లో int


   printf("%d\n", arr[0].i);
   printf("%f\n", arr[1].f);
   printf("%d\n", arr[2].i);


   return 0;
}
```


**వివరణ:**


1. ప్రతి ఎరే ఎలిమెంట్ (`arr[0]`, `arr[1]`, etc.) ఒక **వేర్వేరు** యూనియన్.
2. ఒక్కో దానికి **సొంత** మెమరీ ఉంటుంది.
3. కానీ ఆ **ఒక్కో ఎలిమెంట్ లోపల**, మెంబర్స్ మెమరీని షేర్ చేసుకుంటారు.


-----


## 16\. ఫైనల్ గా ఇలా గుర్తుపెట్టుకోండి (Mental Model)


> **Union అనేది ఒకే మెమరీ బాక్స్, కానీ దానికి రకరకాల స్టిక్కర్లు (Labels) ఉంటాయి. మనం ఏ స్టిక్కర్ చూస్తే ఆ వాల్యూ కనిపిస్తుంది.**


-----


## 17\. ముగింపు (Conclusion)


**స్టూడెంట్స్ గుర్తుంచుకోవాల్సినవి:**


1. Union ఒక డేటా టైప్.
2. Union వేరియబుల్ కి మెమరీ, అడ్రస్ ఉంటాయి.
3. ఒకేసారి ఒక్క మెంబర్ మాత్రమే వాలిడ్.
4. సైజు = అందరిలో పెద్ద మెంబర్ సైజు.
5. Union ని పాయింటర్స్ తో వాడొచ్చు.
6. Union ని Call by Reference ద్వారా పంపొచ్చు.
7. Union లతో ఎరేస్ క్రియేట్ చేయొచ్చు.
8. **ఏది వాడుతున్నామో ప్రోగ్రామరే గుర్తుపెట్టుకోవాలి.**


**ఒక్క ముక్కలో చెప్పాలంటే:**


> **డేటా ఒకదానికొకటి సంబంధం లేకుండా (Mutually exclusive) ఉన్నప్పుడు మాత్రమే Union వాడండి. అందరూ కలిసి ఉండాలనుకుంటే Union వాడకండి (Structure వాడండి).**



