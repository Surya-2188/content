

#  పూర్తి సెక్షన్


## స్ట్రక్చర్స్, పాయింటర్స్ మరియు మెంబర్ యాక్సెస్ (`*`, `.`, `->`) — ఫైనల్ క్లారిటీ


ఇప్పటి వరకు మనం నేర్చుకున్నవన్నీ ఇక్కడ కలుస్తాయి:


 * బేసిక్ వేరియబుల్స్
 * పాయింటర్స్
 * స్ట్రక్చర్స్
 * స్ట్రక్చర్ పాయింటర్స్
 * అసలు `->` (Arrow) ఎందుకు ఉంది?
 * `*` కి, `.` కి మరియు `->` కి తేడా ఏంటి?


మనం నెమ్మదిగా, మనకు తెలిసిన వాటితోనే మొదలుపెడదాం.


-----


## 1\. మనకు బాగా తెలిసిన చిన్న ఉదాహరణ: సాధారణ వేరియబుల్


### 1.1 ఒక మామూలు `int` వేరియబుల్


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   printf("%d\n", x);
   return 0;
}
```


**వివరణ:**


 * `int x = 10;`
     * `int` $\rightarrow$ డేటా టైప్.
     * `x` $\rightarrow$ వేరియబుల్ పేరు.
 * ఒక మెమరీ బాక్స్ క్రియేట్ అయ్యి, అందులో 10 అనే వాల్యూ స్టోర్ అవుతుంది.
 * `x` అనేది ఆ వాల్యూని **డైరెక్ట్ గా** కలిగి ఉంటుంది.


**కీ పాయింట్:** మామూలు వేరియబుల్ అంటే వాల్యూని నేరుగా దాచుకునేది.


-----


## 2\. పాయింటర్ (రివిజన్)


### 2.1 ఒక ఇంటిజర్ కి పాయింటర్


```c
#include <stdio.h>


int main(void) {
   int x = 10;
   int *p = &x;


   printf("Value of x: %d\n", x);
   printf("Value using pointer: %d\n", *p);


   return 0;
}
```


**వివరణ:**


 * `int *p`
     * ఇక్కడ `*` అంటే *"p అనేది ఒక పాయింటర్ వేరియబుల్"* అని అర్థం.
 * `p = &x`
     * `&x` అంటే `x` యొక్క **అడ్రస్**.
     * `p` ఆ అడ్రస్ ని దాచుకుంటుంది.
 * `*p`
     * దీని అర్థం *"p లో ఉన్న అడ్రస్ దగ్గరికి వెళ్లి, అక్కడ ఉన్న **వాల్యూ** తీసుకురా"*.


| పదం | అర్థం |
| :--- | :--- |
| `p` | అడ్రస్ (Address) |
| `*p` | ఆ అడ్రస్ లో ఉన్న వాల్యూ (Value) |


**గుర్తుపెట్టుకోండి:** `*` వాడితే అడ్రస్ లో ఉన్న వాల్యూ వస్తుంది.


-----


## 3\. సొంత డేటా టైప్స్: Structure Variable


### 3.1 స్ట్రక్చర్ ని డిఫైన్ చేయడం, వాడటం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
   char grade;
};


int main(void) {
   struct Student s;


   s.roll = 1;
   s.marks = 85.5;


   printf("Roll: %d\n", s.roll);
   printf("Marks: %.2f\n", s.marks);


   return 0;
}
```


**వివరణ:**


 * `struct Student` $\rightarrow$ మనం క్రియేట్ చేసిన డేటా టైప్.
 * `struct Student s` $\rightarrow$ ఒక స్ట్రక్చర్ వేరియబుల్ తయారైంది. మెమరీ అలకేట్ అయ్యింది.
 * `s.roll`, `s.marks` $\rightarrow$ మెంబర్స్ ని వాడటానికి **డాట్ (`.`) ఆపరేటర్** వాడాం.


**రూల్:** మీ చేతిలో స్ట్రక్చర్ **వేరియబుల్** ఉంటే, డాట్ (`.`) వాడండి.


-----


## 4\. స్ట్రక్చర్ కి పాయింటర్ (అసలు మలుపు ఇక్కడే)


ఇప్పుడు స్ట్రక్చర్స్ ని, పాయింటర్స్ ని కలుపుదాం.


### 4.1 Pointer to Structure


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s;
   struct Student *p = &s;


   p->roll = 10;
   p->marks = 90.0;


   printf("Roll: %d\n", p->roll);
   printf("Marks: %.2f\n", p->marks);


   return 0;
}
```


-----


## 5\. లైన్-బై-లైన్ వివరణ (చాలా ముఖ్యం)


**Step 1: Structure Variable**
`struct Student s;`


 * ఒక స్ట్రక్చర్ వేరియబుల్ క్రియేట్ అయ్యింది. దానికి మెమరీ, అడ్రస్ ఉన్నాయి.


**Step 2: Pointer to Structure**
`struct Student *p = &s;`


 * `struct Student *p`: `p` అనేది స్టూడెంట్ స్ట్రక్చర్ అడ్రస్ ని దాచుకోగలిగే పాయింటర్.
 * `&s`: `s` యొక్క అడ్రస్ ని `p` లో పెట్టాం.


ఇప్పుడు:


 * `p` $\rightarrow$ అడ్రస్
 * `*p` $\rightarrow$ మొత్తం స్ట్రక్చర్


-----


## 6\. `*p.roll` అని రాస్తే ఎందుకు తప్పు?


చాలామంది స్టూడెంట్స్ ఇలా రాస్తారు:


```c
*p.roll = 10;   // ❌ తప్పు (WRONG)
```


**ఎందుకు?**
ఎందుకంటే C లాంగ్వేజ్ దీన్ని `*(p.roll)` అని చదువుతుంది.
కానీ `p` అనేది పాయింటర్ (అడ్రస్). అడ్రస్ కి `roll` నంబర్ ఉండదు కదా\! స్ట్రక్చర్ కి ఉంటుంది. అందుకే ఎర్రర్ వస్తుంది.


-----


## 7\. కరెక్టే కానీ... చూడటానికి బాగోని పద్ధతి


```c
(*p).roll = 10;   // ✅ కరెక్ట్
```


**అర్థం:**


1. `*p` $\rightarrow$ ముందు పాయింటర్ దగ్గరికి వెళ్లి స్ట్రక్చర్ ని పట్టుకో.
2. `.roll` $\rightarrow$ ఇప్పుడు ఆ స్ట్రక్చర్ లోని `roll` ని తీసుకో.


ఇది పనిచేస్తుంది, కానీ రాయడానికి కష్టంగా ఉంటుంది (ప్రతిసారీ బ్రాకెట్లు పెట్టాలి).


-----


## 8\. Arrow Operator (`->`) — ఇది ఎందుకు పుట్టింది?


ఆ బ్రాకెట్ల గొడవ లేకుండా, సింపుల్ గా ఉండటానికి C లో **ఆరో ఆపరేటర్ (`->`)** ని తెచ్చారు.


```c
p->roll = 10;
```


**అర్థం:** `p` చూపించే అడ్రస్ కి వెళ్లి, అక్కడ ఉన్న `roll` ని యాక్సెస్ చెయ్యి.


సో:
$$p \rightarrow roll \equiv (*p).roll$$
ఈ రెండూ ఒక్కటే.


-----


## 9\. పోలిక పట్టిక (బండ గుర్తు)


| పరిస్థితి | రాయాల్సిన పద్ధతి (Syntax) |
| :--- | :--- |
| మామూలు వేరియబుల్ | `x` |
| ఇంటిజర్ పాయింటర్ | `*p` |
| స్ట్రక్చర్ వేరియబుల్ | `s.roll` |
| స్ట్రక్చర్ పాయింటర్ | `p->roll` |


-----


## 10\. పాయింటర్ తో డాట్ (`.`) ఎందుకు వాడకూడదు?


```c
p.roll = 10;   // ❌ తప్పు
```


**ఎందుకు?** `p` అనేది స్ట్రక్చర్ కాదు, అదొక **అడ్రస్** మాత్రమే.
**రూల్:** డాట్ (`.`) కేవలం అసలైన స్ట్రక్చర్ వేరియబుల్స్ తోనే పనిచేస్తుంది.


-----


## 11\. మెమరీ లేకుండా పాయింటర్ వాడితే (Danger Zone)


```c
struct Student *p;
p->roll = 10;   // ❌ ప్రమాదం! (Undefined Behavior)
```


**ఎందుకు?** `p` ఎక్కడికో (తెలియని చోటకి) పాయింట్ చేస్తోంది. మెమరీ అలకేట్ చేయలేదు. గాలిలో ఇల్లు కట్టినట్టే.


-----


## 12\. స్ట్రక్చర్ పాయింటర్స్ ని వాడే సరైన పద్ధతులు


**Case 1: ఉన్న స్ట్రక్చర్ కి పాయింట్ చేయడం**


```c
struct Student s;
struct Student *p = &s;
p->roll = 5;    // ✅ సేఫ్
```


**Case 2: `malloc` వాడి మెమరీ ఇవ్వడం**


```c
#include <stdio.h>
#include <stdlib.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   // మెమరీని క్రియేట్ చేస్తున్నాం
   struct Student *p = malloc(sizeof(struct Student));


   p->roll = 20;
   p->marks = 75.0;


   printf("Roll: %d\n", p->roll);
   printf("Marks: %.2f\n", p->marks);


   free(p); // మెమరీని క్లీన్ చేస్తున్నాం
   return 0;
}
```


**వివరణ:**


 * `malloc` మెమరీని ఇస్తుంది.
 * `p` ఇప్పుడు ఒక వాలిడ్ మెమరీని చూపిస్తోంది.
 * `->` వాడి వాల్యూస్ పెట్టాం.
 * `free` వాడి క్లీన్ చేసాం.


-----


## 13\. ఫైనల్ గా మెదడులో ముద్రించుకోవాల్సినవి


1. పాయింటర్ ఎప్పుడూ డేటాని దాచుకోదు. **అడ్రస్** ని దాచుకుంటుంది.
2. `*` $\rightarrow$ అడ్రస్ లో ఉన్న వాల్యూ.
3. `.` $\rightarrow$ స్ట్రక్చర్ లోని మెంబర్.
4. `->` $\rightarrow$ పాయింటర్ ద్వారా మెంబర్ ని పిలవాలంటే.


### ఒక్క ముక్కలో చెప్పాలంటే...


**స్ట్రక్చర్స్ డేటాని గ్రూప్ చేస్తాయి, పాయింటర్స్ మెమరీని చూపిస్తాయి, ఆ రెండింటినీ కలపడానికే ఈ ఆరో (`->`) ఉంది.**


-----


# సాధారణ తప్పులు (Common Mistakes)


ఈ సెక్షన్ చాలా ముఖ్యం. చాలా ప్రోగ్రామ్స్ రన్ అవుతాయి కానీ తప్పు ఆన్సర్ ఇస్తాయి. అందుకే జాగ్రత్తగా చూడండి.


###  Mistake 1: పాయింటర్ కి `->` బదులు `.` వాడటం


```c
#include <stdio.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student s;
   struct Student *p = &s;


   p.roll = 10;        // ❌ తప్పు
   printf("%d\n", p.roll);


   return 0;
}
```


**వివరణ:** `p` పాయింటర్. డాట్ (`.`) కేవలం వేరియబుల్స్ కి మాత్రమే.
*కంపైలర్ ఎర్రర్:* “request for member in something not a structure”
**Correct Line:** `p->roll = 10;`


###  Mistake 2: `*p.roll` అని రాయడం (బ్రాకెట్లు లేకుండా)


```c
#include <stdio.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student s;
   struct Student *p = &s;


   *p.roll = 5;        // ❌ తప్పు
   printf("%d\n", s.roll);


   return 0;
}
```


**వివరణ:** C దీన్ని `*(p.roll)` అనుకుంటుంది. `p.roll` లేదు కాబట్టి ఎర్రర్ వస్తుంది.
**Correct Line:** `(*p).roll = 5;` (లేదా ఇంకా బెటర్: `p->roll = 5;`)


### Mistake 3: మెమరీ లేకుండా పాయింటర్ వాడటం


```c
#include <stdio.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student *p;


   p->roll = 10;       // ❌ తప్పు (క్రాష్ అవుతుంది)
   printf("%d\n", p->roll);


   return 0;
}
```


**వివరణ:** `p` లో చెత్త అడ్రస్ ఉంది. దాన్ని వాడితే ప్రోగ్రామ్ పేలిపోతుంది (Crash).
**Fix:** ఉన్న వేరియబుల్ అడ్రస్ ఇవ్వండి (`p=&s;`) లేదా `malloc` వాడండి.


###  Mistake 4: `malloc` లో సైజు తప్పుగా ఇవ్వడం


```c
#include <stdio.h>
#include <stdlib.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student *p = malloc(sizeof(p));   // ❌ తప్పు
   return 0;
}
```


**వివరణ:** `sizeof(p)` పాయింటర్ సైజు (8 బైట్లు) ఇస్తుంది. కానీ మనకు కావాల్సింది స్ట్రక్చర్ సైజు. మెమరీ సరిపోదు.
**Correct Line:** `struct Student *p = malloc(sizeof(struct Student));`


###  Mistake 5: `*p` అంటే మెంబర్ వస్తుందనుకోవడం


```c
#include <stdio.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student s = {10};
   struct Student *p = &s;


   printf("%d\n", *p);     // ❌ తప్పు


   return 0;
}
```


**వివరణ:** `*p` అంటే మొత్తం స్ట్రక్చర్ వస్తుంది. `printf` కి `int` కావాలి. టైప్ మ్యాచ్ అవ్వదు.
 **Correct Line:** `printf("%d\n", p->roll);`


### Mistake 6: స్ట్రక్చర్ ని ఎరే లాగా ట్రీట్ చేయడం


```c
#include <stdio.h>


struct Student {
   int roll;
   float marks;
};


int main(void) {
   struct Student s;


   s[0] = 10;          // ❌ తప్పు
   printf("%d\n", s.roll);


   return 0;
}
```


**వివరణ:** స్ట్రక్చర్స్ కి ఇండెక్స్ లు ఉండవు. `s.roll` అనే పిలవాలి.


###  Mistake 7: పాయింటర్ కాని దానికి `->` వాడటం


```c
#include <stdio.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student s;


   s->roll = 5;        // ❌ తప్పు
   printf("%d\n", s.roll);


   return 0;
}
```


**వివరణ:** `s` మామూలు వేరియబుల్. దానికి డాట్ (`.`) వాడాలి. `->` కేవలం పాయింటర్స్ కి మాత్రమే.**Correct Line:** `s.roll = 5;`


###  Mistake 8: డిక్లరేషన్ లో `*` కి, వాడేటప్పుడు `*` కి కన్ఫ్యూజ్ అవ్వడం


```c
struct Student *p;
```


**తప్పు ఆలోచన:** "\*p కి ఆల్రెడీ వాల్యూ ఉంది."
**నిజం:**


 * డిక్లరేషన్ లో `*` $\rightarrow$ ఇది పాయింటర్ అని చెప్తుంది.
 * వాడేటప్పుడు `*` $\rightarrow$ వాల్యూని తెస్తుంది.
   ఈ రెండూ వేరు వేరు.


###  Mistake 9: `malloc` చేసాక `free` చేయడం మర్చిపోవడం


```c
#include <stdlib.h>


struct Student {
   int roll;
};


int main(void) {
   struct Student *p = malloc(sizeof(struct Student));
   p->roll = 10;
   return 0;          // ❌ మెమరీ లీక్
}
```


**వివరణ:** ప్రోగ్రామ్ అయిపోయాక మెమరీ అలాగే ఉండిపోతుంది (Memory Leak).
**Correct Line:** `free(p);`


###  Mistake 10: స్ట్రక్చర్ ని కాపీ చేస్తే పాయింటర్ కాపీ అవుతుందనుకోవడం


```c
struct Student a = {1, 90};
struct Student b = a;
```


**తప్పు ఆలోచన:** "b ఇప్పుడు a ని పాయింట్ చేస్తోంది."
**నిజం:** ఇది **వాల్యూ కాపీ (Xerox)**. `a` వేరు, `b` వేరు. ఒకదానిలో మారిస్తే ఇంకోదానిలో మారదు.


-----


###  చివరిగా ఒక వార్నింగ్


స్ట్రక్చర్-పాయింటర్ తప్పులు చాలా వరకూ ఎర్రర్స్ చూపించవు. ప్రోగ్రామ్ రన్ అవుతుంది, కానీ తప్పు ఆన్సర్స్ ఇస్తుంది లేదా క్రాష్ అవుతుంది. అందుకే ఇవి చాలా ప్రమాదకరం.


###  ముగింపు వాక్యం


**ఎప్పుడు `*` వాడాలి, ఎప్పుడు `.` వాడాలి, ఎప్పుడు `->` వాడాలి అని మీకు తెలిస్తే, C లో స్ట్రక్చర్స్ మరియు పాయింటర్స్ మీ గుప్పెట్లో ఉన్నట్టే\!**

